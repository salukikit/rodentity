// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/salukikit/rodentity/ent/device"
	"github.com/salukikit/rodentity/ent/domain"
	"github.com/salukikit/rodentity/ent/group"
	"github.com/salukikit/rodentity/ent/loot"
	"github.com/salukikit/rodentity/ent/operator"
	"github.com/salukikit/rodentity/ent/predicate"
	"github.com/salukikit/rodentity/ent/project"
	"github.com/salukikit/rodentity/ent/rodent"
	"github.com/salukikit/rodentity/ent/router"
	"github.com/salukikit/rodentity/ent/subnet"
	"github.com/salukikit/rodentity/ent/task"
	"github.com/salukikit/rodentity/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDevice   = "Device"
	TypeDomain   = "Domain"
	TypeGroup    = "Group"
	TypeLoot     = "Loot"
	TypeOperator = "Operator"
	TypeProject  = "Project"
	TypeRodent   = "Rodent"
	TypeRouter   = "Router"
	TypeSubnet   = "Subnet"
	TypeTask     = "Task"
	TypeUser     = "User"
)

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op             Op
	typ            string
	id             *int
	hostname       *string
	os             *string
	arch           *string
	version        *string
	localaddress   *string
	machinepass    *string
	certificates   *string
	clearedFields  map[string]struct{}
	users          map[int]struct{}
	removedusers   map[int]struct{}
	clearedusers   bool
	rodents        map[int]struct{}
	removedrodents map[int]struct{}
	clearedrodents bool
	groups         map[int]struct{}
	removedgroups  map[int]struct{}
	clearedgroups  bool
	domain         *int
	cleareddomain  bool
	subnets        map[int]struct{}
	removedsubnets map[int]struct{}
	clearedsubnets bool
	done           bool
	oldValue       func(context.Context) (*Device, error)
	predicates     []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id int) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostname sets the "hostname" field.
func (m *DeviceMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *DeviceMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *DeviceMutation) ResetHostname() {
	m.hostname = nil
}

// SetOs sets the "os" field.
func (m *DeviceMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *DeviceMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *DeviceMutation) ResetOs() {
	m.os = nil
}

// SetArch sets the "arch" field.
func (m *DeviceMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *DeviceMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ResetArch resets all changes to the "arch" field.
func (m *DeviceMutation) ResetArch() {
	m.arch = nil
}

// SetVersion sets the "version" field.
func (m *DeviceMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *DeviceMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *DeviceMutation) ResetVersion() {
	m.version = nil
}

// SetLocaladdress sets the "localaddress" field.
func (m *DeviceMutation) SetLocaladdress(s string) {
	m.localaddress = &s
}

// Localaddress returns the value of the "localaddress" field in the mutation.
func (m *DeviceMutation) Localaddress() (r string, exists bool) {
	v := m.localaddress
	if v == nil {
		return
	}
	return *v, true
}

// OldLocaladdress returns the old "localaddress" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldLocaladdress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocaladdress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocaladdress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocaladdress: %w", err)
	}
	return oldValue.Localaddress, nil
}

// ResetLocaladdress resets all changes to the "localaddress" field.
func (m *DeviceMutation) ResetLocaladdress() {
	m.localaddress = nil
}

// SetMachinepass sets the "machinepass" field.
func (m *DeviceMutation) SetMachinepass(s string) {
	m.machinepass = &s
}

// Machinepass returns the value of the "machinepass" field in the mutation.
func (m *DeviceMutation) Machinepass() (r string, exists bool) {
	v := m.machinepass
	if v == nil {
		return
	}
	return *v, true
}

// OldMachinepass returns the old "machinepass" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldMachinepass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMachinepass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMachinepass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMachinepass: %w", err)
	}
	return oldValue.Machinepass, nil
}

// ClearMachinepass clears the value of the "machinepass" field.
func (m *DeviceMutation) ClearMachinepass() {
	m.machinepass = nil
	m.clearedFields[device.FieldMachinepass] = struct{}{}
}

// MachinepassCleared returns if the "machinepass" field was cleared in this mutation.
func (m *DeviceMutation) MachinepassCleared() bool {
	_, ok := m.clearedFields[device.FieldMachinepass]
	return ok
}

// ResetMachinepass resets all changes to the "machinepass" field.
func (m *DeviceMutation) ResetMachinepass() {
	m.machinepass = nil
	delete(m.clearedFields, device.FieldMachinepass)
}

// SetCertificates sets the "certificates" field.
func (m *DeviceMutation) SetCertificates(s string) {
	m.certificates = &s
}

// Certificates returns the value of the "certificates" field in the mutation.
func (m *DeviceMutation) Certificates() (r string, exists bool) {
	v := m.certificates
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificates returns the old "certificates" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCertificates(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificates: %w", err)
	}
	return oldValue.Certificates, nil
}

// ClearCertificates clears the value of the "certificates" field.
func (m *DeviceMutation) ClearCertificates() {
	m.certificates = nil
	m.clearedFields[device.FieldCertificates] = struct{}{}
}

// CertificatesCleared returns if the "certificates" field was cleared in this mutation.
func (m *DeviceMutation) CertificatesCleared() bool {
	_, ok := m.clearedFields[device.FieldCertificates]
	return ok
}

// ResetCertificates resets all changes to the "certificates" field.
func (m *DeviceMutation) ResetCertificates() {
	m.certificates = nil
	delete(m.clearedFields, device.FieldCertificates)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *DeviceMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *DeviceMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *DeviceMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *DeviceMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *DeviceMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *DeviceMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DeviceMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddRodentIDs adds the "rodents" edge to the Rodent entity by ids.
func (m *DeviceMutation) AddRodentIDs(ids ...int) {
	if m.rodents == nil {
		m.rodents = make(map[int]struct{})
	}
	for i := range ids {
		m.rodents[ids[i]] = struct{}{}
	}
}

// ClearRodents clears the "rodents" edge to the Rodent entity.
func (m *DeviceMutation) ClearRodents() {
	m.clearedrodents = true
}

// RodentsCleared reports if the "rodents" edge to the Rodent entity was cleared.
func (m *DeviceMutation) RodentsCleared() bool {
	return m.clearedrodents
}

// RemoveRodentIDs removes the "rodents" edge to the Rodent entity by IDs.
func (m *DeviceMutation) RemoveRodentIDs(ids ...int) {
	if m.removedrodents == nil {
		m.removedrodents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rodents, ids[i])
		m.removedrodents[ids[i]] = struct{}{}
	}
}

// RemovedRodents returns the removed IDs of the "rodents" edge to the Rodent entity.
func (m *DeviceMutation) RemovedRodentsIDs() (ids []int) {
	for id := range m.removedrodents {
		ids = append(ids, id)
	}
	return
}

// RodentsIDs returns the "rodents" edge IDs in the mutation.
func (m *DeviceMutation) RodentsIDs() (ids []int) {
	for id := range m.rodents {
		ids = append(ids, id)
	}
	return
}

// ResetRodents resets all changes to the "rodents" edge.
func (m *DeviceMutation) ResetRodents() {
	m.rodents = nil
	m.clearedrodents = false
	m.removedrodents = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *DeviceMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *DeviceMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *DeviceMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *DeviceMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *DeviceMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *DeviceMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *DeviceMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// SetDomainID sets the "domain" edge to the Domain entity by id.
func (m *DeviceMutation) SetDomainID(id int) {
	m.domain = &id
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *DeviceMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *DeviceMutation) DomainCleared() bool {
	return m.cleareddomain
}

// DomainID returns the "domain" edge ID in the mutation.
func (m *DeviceMutation) DomainID() (id int, exists bool) {
	if m.domain != nil {
		return *m.domain, true
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DomainID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) DomainIDs() (ids []int) {
	if id := m.domain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *DeviceMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
}

// AddSubnetIDs adds the "subnets" edge to the Subnet entity by ids.
func (m *DeviceMutation) AddSubnetIDs(ids ...int) {
	if m.subnets == nil {
		m.subnets = make(map[int]struct{})
	}
	for i := range ids {
		m.subnets[ids[i]] = struct{}{}
	}
}

// ClearSubnets clears the "subnets" edge to the Subnet entity.
func (m *DeviceMutation) ClearSubnets() {
	m.clearedsubnets = true
}

// SubnetsCleared reports if the "subnets" edge to the Subnet entity was cleared.
func (m *DeviceMutation) SubnetsCleared() bool {
	return m.clearedsubnets
}

// RemoveSubnetIDs removes the "subnets" edge to the Subnet entity by IDs.
func (m *DeviceMutation) RemoveSubnetIDs(ids ...int) {
	if m.removedsubnets == nil {
		m.removedsubnets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subnets, ids[i])
		m.removedsubnets[ids[i]] = struct{}{}
	}
}

// RemovedSubnets returns the removed IDs of the "subnets" edge to the Subnet entity.
func (m *DeviceMutation) RemovedSubnetsIDs() (ids []int) {
	for id := range m.removedsubnets {
		ids = append(ids, id)
	}
	return
}

// SubnetsIDs returns the "subnets" edge IDs in the mutation.
func (m *DeviceMutation) SubnetsIDs() (ids []int) {
	for id := range m.subnets {
		ids = append(ids, id)
	}
	return
}

// ResetSubnets resets all changes to the "subnets" edge.
func (m *DeviceMutation) ResetSubnets() {
	m.subnets = nil
	m.clearedsubnets = false
	m.removedsubnets = nil
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.hostname != nil {
		fields = append(fields, device.FieldHostname)
	}
	if m.os != nil {
		fields = append(fields, device.FieldOs)
	}
	if m.arch != nil {
		fields = append(fields, device.FieldArch)
	}
	if m.version != nil {
		fields = append(fields, device.FieldVersion)
	}
	if m.localaddress != nil {
		fields = append(fields, device.FieldLocaladdress)
	}
	if m.machinepass != nil {
		fields = append(fields, device.FieldMachinepass)
	}
	if m.certificates != nil {
		fields = append(fields, device.FieldCertificates)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldHostname:
		return m.Hostname()
	case device.FieldOs:
		return m.Os()
	case device.FieldArch:
		return m.Arch()
	case device.FieldVersion:
		return m.Version()
	case device.FieldLocaladdress:
		return m.Localaddress()
	case device.FieldMachinepass:
		return m.Machinepass()
	case device.FieldCertificates:
		return m.Certificates()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldHostname:
		return m.OldHostname(ctx)
	case device.FieldOs:
		return m.OldOs(ctx)
	case device.FieldArch:
		return m.OldArch(ctx)
	case device.FieldVersion:
		return m.OldVersion(ctx)
	case device.FieldLocaladdress:
		return m.OldLocaladdress(ctx)
	case device.FieldMachinepass:
		return m.OldMachinepass(ctx)
	case device.FieldCertificates:
		return m.OldCertificates(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case device.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case device.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case device.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case device.FieldLocaladdress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocaladdress(v)
		return nil
	case device.FieldMachinepass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMachinepass(v)
		return nil
	case device.FieldCertificates:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificates(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldMachinepass) {
		fields = append(fields, device.FieldMachinepass)
	}
	if m.FieldCleared(device.FieldCertificates) {
		fields = append(fields, device.FieldCertificates)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldMachinepass:
		m.ClearMachinepass()
		return nil
	case device.FieldCertificates:
		m.ClearCertificates()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldHostname:
		m.ResetHostname()
		return nil
	case device.FieldOs:
		m.ResetOs()
		return nil
	case device.FieldArch:
		m.ResetArch()
		return nil
	case device.FieldVersion:
		m.ResetVersion()
		return nil
	case device.FieldLocaladdress:
		m.ResetLocaladdress()
		return nil
	case device.FieldMachinepass:
		m.ResetMachinepass()
		return nil
	case device.FieldCertificates:
		m.ResetCertificates()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.users != nil {
		edges = append(edges, device.EdgeUsers)
	}
	if m.rodents != nil {
		edges = append(edges, device.EdgeRodents)
	}
	if m.groups != nil {
		edges = append(edges, device.EdgeGroups)
	}
	if m.domain != nil {
		edges = append(edges, device.EdgeDomain)
	}
	if m.subnets != nil {
		edges = append(edges, device.EdgeSubnets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeRodents:
		ids := make([]ent.Value, 0, len(m.rodents))
		for id := range m.rodents {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDomain:
		if id := m.domain; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeSubnets:
		ids := make([]ent.Value, 0, len(m.subnets))
		for id := range m.subnets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedusers != nil {
		edges = append(edges, device.EdgeUsers)
	}
	if m.removedrodents != nil {
		edges = append(edges, device.EdgeRodents)
	}
	if m.removedgroups != nil {
		edges = append(edges, device.EdgeGroups)
	}
	if m.removedsubnets != nil {
		edges = append(edges, device.EdgeSubnets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeRodents:
		ids := make([]ent.Value, 0, len(m.removedrodents))
		for id := range m.removedrodents {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeSubnets:
		ids := make([]ent.Value, 0, len(m.removedsubnets))
		for id := range m.removedsubnets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedusers {
		edges = append(edges, device.EdgeUsers)
	}
	if m.clearedrodents {
		edges = append(edges, device.EdgeRodents)
	}
	if m.clearedgroups {
		edges = append(edges, device.EdgeGroups)
	}
	if m.cleareddomain {
		edges = append(edges, device.EdgeDomain)
	}
	if m.clearedsubnets {
		edges = append(edges, device.EdgeSubnets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeUsers:
		return m.clearedusers
	case device.EdgeRodents:
		return m.clearedrodents
	case device.EdgeGroups:
		return m.clearedgroups
	case device.EdgeDomain:
		return m.cleareddomain
	case device.EdgeSubnets:
		return m.clearedsubnets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeDomain:
		m.ClearDomain()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeUsers:
		m.ResetUsers()
		return nil
	case device.EdgeRodents:
		m.ResetRodents()
		return nil
	case device.EdgeGroups:
		m.ResetGroups()
		return nil
	case device.EdgeDomain:
		m.ResetDomain()
		return nil
	case device.EdgeSubnets:
		m.ResetSubnets()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DomainMutation represents an operation that mutates the Domain nodes in the graph.
type DomainMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	_AD                 *bool
	owned               *bool
	cloud               *string
	clearedFields       map[string]struct{}
	devices             map[int]struct{}
	removeddevices      map[int]struct{}
	cleareddevices      bool
	users               map[int]struct{}
	removedusers        map[int]struct{}
	clearedusers        bool
	groups              map[int]struct{}
	removedgroups       map[int]struct{}
	clearedgroups       bool
	childdomains        map[int]struct{}
	removedchilddomains map[int]struct{}
	clearedchilddomains bool
	parentdomain        *int
	clearedparentdomain bool
	done                bool
	oldValue            func(context.Context) (*Domain, error)
	predicates          []predicate.Domain
}

var _ ent.Mutation = (*DomainMutation)(nil)

// domainOption allows management of the mutation configuration using functional options.
type domainOption func(*DomainMutation)

// newDomainMutation creates new mutation for the Domain entity.
func newDomainMutation(c config, op Op, opts ...domainOption) *DomainMutation {
	m := &DomainMutation{
		config:        c,
		op:            op,
		typ:           TypeDomain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDomainID sets the ID field of the mutation.
func withDomainID(id int) domainOption {
	return func(m *DomainMutation) {
		var (
			err   error
			once  sync.Once
			value *Domain
		)
		m.oldValue = func(ctx context.Context) (*Domain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Domain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDomain sets the old Domain of the mutation.
func withDomain(node *Domain) domainOption {
	return func(m *DomainMutation) {
		m.oldValue = func(context.Context) (*Domain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DomainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DomainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DomainMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DomainMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Domain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DomainMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DomainMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DomainMutation) ResetName() {
	m.name = nil
}

// SetAD sets the "AD" field.
func (m *DomainMutation) SetAD(b bool) {
	m._AD = &b
}

// AD returns the value of the "AD" field in the mutation.
func (m *DomainMutation) AD() (r bool, exists bool) {
	v := m._AD
	if v == nil {
		return
	}
	return *v, true
}

// OldAD returns the old "AD" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldAD(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAD is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAD: %w", err)
	}
	return oldValue.AD, nil
}

// ResetAD resets all changes to the "AD" field.
func (m *DomainMutation) ResetAD() {
	m._AD = nil
}

// SetOwned sets the "owned" field.
func (m *DomainMutation) SetOwned(b bool) {
	m.owned = &b
}

// Owned returns the value of the "owned" field in the mutation.
func (m *DomainMutation) Owned() (r bool, exists bool) {
	v := m.owned
	if v == nil {
		return
	}
	return *v, true
}

// OldOwned returns the old "owned" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwned: %w", err)
	}
	return oldValue.Owned, nil
}

// ResetOwned resets all changes to the "owned" field.
func (m *DomainMutation) ResetOwned() {
	m.owned = nil
}

// SetCloud sets the "cloud" field.
func (m *DomainMutation) SetCloud(s string) {
	m.cloud = &s
}

// Cloud returns the value of the "cloud" field in the mutation.
func (m *DomainMutation) Cloud() (r string, exists bool) {
	v := m.cloud
	if v == nil {
		return
	}
	return *v, true
}

// OldCloud returns the old "cloud" field's value of the Domain entity.
// If the Domain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainMutation) OldCloud(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloud is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloud requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloud: %w", err)
	}
	return oldValue.Cloud, nil
}

// ResetCloud resets all changes to the "cloud" field.
func (m *DomainMutation) ResetCloud() {
	m.cloud = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *DomainMutation) AddDeviceIDs(ids ...int) {
	if m.devices == nil {
		m.devices = make(map[int]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *DomainMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *DomainMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *DomainMutation) RemoveDeviceIDs(ids ...int) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *DomainMutation) RemovedDevicesIDs() (ids []int) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *DomainMutation) DevicesIDs() (ids []int) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *DomainMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *DomainMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *DomainMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *DomainMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *DomainMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *DomainMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *DomainMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DomainMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *DomainMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *DomainMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *DomainMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *DomainMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *DomainMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *DomainMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *DomainMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddChilddomainIDs adds the "childdomains" edge to the Domain entity by ids.
func (m *DomainMutation) AddChilddomainIDs(ids ...int) {
	if m.childdomains == nil {
		m.childdomains = make(map[int]struct{})
	}
	for i := range ids {
		m.childdomains[ids[i]] = struct{}{}
	}
}

// ClearChilddomains clears the "childdomains" edge to the Domain entity.
func (m *DomainMutation) ClearChilddomains() {
	m.clearedchilddomains = true
}

// ChilddomainsCleared reports if the "childdomains" edge to the Domain entity was cleared.
func (m *DomainMutation) ChilddomainsCleared() bool {
	return m.clearedchilddomains
}

// RemoveChilddomainIDs removes the "childdomains" edge to the Domain entity by IDs.
func (m *DomainMutation) RemoveChilddomainIDs(ids ...int) {
	if m.removedchilddomains == nil {
		m.removedchilddomains = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.childdomains, ids[i])
		m.removedchilddomains[ids[i]] = struct{}{}
	}
}

// RemovedChilddomains returns the removed IDs of the "childdomains" edge to the Domain entity.
func (m *DomainMutation) RemovedChilddomainsIDs() (ids []int) {
	for id := range m.removedchilddomains {
		ids = append(ids, id)
	}
	return
}

// ChilddomainsIDs returns the "childdomains" edge IDs in the mutation.
func (m *DomainMutation) ChilddomainsIDs() (ids []int) {
	for id := range m.childdomains {
		ids = append(ids, id)
	}
	return
}

// ResetChilddomains resets all changes to the "childdomains" edge.
func (m *DomainMutation) ResetChilddomains() {
	m.childdomains = nil
	m.clearedchilddomains = false
	m.removedchilddomains = nil
}

// SetParentdomainID sets the "parentdomain" edge to the Domain entity by id.
func (m *DomainMutation) SetParentdomainID(id int) {
	m.parentdomain = &id
}

// ClearParentdomain clears the "parentdomain" edge to the Domain entity.
func (m *DomainMutation) ClearParentdomain() {
	m.clearedparentdomain = true
}

// ParentdomainCleared reports if the "parentdomain" edge to the Domain entity was cleared.
func (m *DomainMutation) ParentdomainCleared() bool {
	return m.clearedparentdomain
}

// ParentdomainID returns the "parentdomain" edge ID in the mutation.
func (m *DomainMutation) ParentdomainID() (id int, exists bool) {
	if m.parentdomain != nil {
		return *m.parentdomain, true
	}
	return
}

// ParentdomainIDs returns the "parentdomain" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentdomainID instead. It exists only for internal usage by the builders.
func (m *DomainMutation) ParentdomainIDs() (ids []int) {
	if id := m.parentdomain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentdomain resets all changes to the "parentdomain" edge.
func (m *DomainMutation) ResetParentdomain() {
	m.parentdomain = nil
	m.clearedparentdomain = false
}

// Where appends a list predicates to the DomainMutation builder.
func (m *DomainMutation) Where(ps ...predicate.Domain) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DomainMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DomainMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Domain, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DomainMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DomainMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Domain).
func (m *DomainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DomainMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, domain.FieldName)
	}
	if m._AD != nil {
		fields = append(fields, domain.FieldAD)
	}
	if m.owned != nil {
		fields = append(fields, domain.FieldOwned)
	}
	if m.cloud != nil {
		fields = append(fields, domain.FieldCloud)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DomainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case domain.FieldName:
		return m.Name()
	case domain.FieldAD:
		return m.AD()
	case domain.FieldOwned:
		return m.Owned()
	case domain.FieldCloud:
		return m.Cloud()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DomainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case domain.FieldName:
		return m.OldName(ctx)
	case domain.FieldAD:
		return m.OldAD(ctx)
	case domain.FieldOwned:
		return m.OldOwned(ctx)
	case domain.FieldCloud:
		return m.OldCloud(ctx)
	}
	return nil, fmt.Errorf("unknown Domain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case domain.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case domain.FieldAD:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAD(v)
		return nil
	case domain.FieldOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwned(v)
		return nil
	case domain.FieldCloud:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloud(v)
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DomainMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DomainMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Domain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DomainMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DomainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DomainMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Domain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DomainMutation) ResetField(name string) error {
	switch name {
	case domain.FieldName:
		m.ResetName()
		return nil
	case domain.FieldAD:
		m.ResetAD()
		return nil
	case domain.FieldOwned:
		m.ResetOwned()
		return nil
	case domain.FieldCloud:
		m.ResetCloud()
		return nil
	}
	return fmt.Errorf("unknown Domain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DomainMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.devices != nil {
		edges = append(edges, domain.EdgeDevices)
	}
	if m.users != nil {
		edges = append(edges, domain.EdgeUsers)
	}
	if m.groups != nil {
		edges = append(edges, domain.EdgeGroups)
	}
	if m.childdomains != nil {
		edges = append(edges, domain.EdgeChilddomains)
	}
	if m.parentdomain != nil {
		edges = append(edges, domain.EdgeParentdomain)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DomainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeChilddomains:
		ids := make([]ent.Value, 0, len(m.childdomains))
		for id := range m.childdomains {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeParentdomain:
		if id := m.parentdomain; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DomainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeddevices != nil {
		edges = append(edges, domain.EdgeDevices)
	}
	if m.removedusers != nil {
		edges = append(edges, domain.EdgeUsers)
	}
	if m.removedgroups != nil {
		edges = append(edges, domain.EdgeGroups)
	}
	if m.removedchilddomains != nil {
		edges = append(edges, domain.EdgeChilddomains)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DomainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case domain.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case domain.EdgeChilddomains:
		ids := make([]ent.Value, 0, len(m.removedchilddomains))
		for id := range m.removedchilddomains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DomainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareddevices {
		edges = append(edges, domain.EdgeDevices)
	}
	if m.clearedusers {
		edges = append(edges, domain.EdgeUsers)
	}
	if m.clearedgroups {
		edges = append(edges, domain.EdgeGroups)
	}
	if m.clearedchilddomains {
		edges = append(edges, domain.EdgeChilddomains)
	}
	if m.clearedparentdomain {
		edges = append(edges, domain.EdgeParentdomain)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DomainMutation) EdgeCleared(name string) bool {
	switch name {
	case domain.EdgeDevices:
		return m.cleareddevices
	case domain.EdgeUsers:
		return m.clearedusers
	case domain.EdgeGroups:
		return m.clearedgroups
	case domain.EdgeChilddomains:
		return m.clearedchilddomains
	case domain.EdgeParentdomain:
		return m.clearedparentdomain
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DomainMutation) ClearEdge(name string) error {
	switch name {
	case domain.EdgeParentdomain:
		m.ClearParentdomain()
		return nil
	}
	return fmt.Errorf("unknown Domain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DomainMutation) ResetEdge(name string) error {
	switch name {
	case domain.EdgeDevices:
		m.ResetDevices()
		return nil
	case domain.EdgeUsers:
		m.ResetUsers()
		return nil
	case domain.EdgeGroups:
		m.ResetGroups()
		return nil
	case domain.EdgeChilddomains:
		m.ResetChilddomains()
		return nil
	case domain.EdgeParentdomain:
		m.ResetParentdomain()
		return nil
	}
	return fmt.Errorf("unknown Domain edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	description    *string
	permissions    *string
	clearedFields  map[string]struct{}
	devices        map[int]struct{}
	removeddevices map[int]struct{}
	cleareddevices bool
	users          map[int]struct{}
	removedusers   map[int]struct{}
	clearedusers   bool
	domain         *int
	cleareddomain  bool
	done           bool
	oldValue       func(context.Context) (*Group, error)
	predicates     []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupMutation) ResetDescription() {
	m.description = nil
}

// SetPermissions sets the "permissions" field.
func (m *GroupMutation) SetPermissions(s string) {
	m.permissions = &s
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *GroupMutation) Permissions() (r string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldPermissions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *GroupMutation) ResetPermissions() {
	m.permissions = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *GroupMutation) AddDeviceIDs(ids ...int) {
	if m.devices == nil {
		m.devices = make(map[int]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *GroupMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *GroupMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *GroupMutation) RemoveDeviceIDs(ids ...int) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *GroupMutation) RemovedDevicesIDs() (ids []int) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *GroupMutation) DevicesIDs() (ids []int) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *GroupMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *GroupMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *GroupMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *GroupMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// SetDomainID sets the "domain" edge to the Domain entity by id.
func (m *GroupMutation) SetDomainID(id int) {
	m.domain = &id
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *GroupMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *GroupMutation) DomainCleared() bool {
	return m.cleareddomain
}

// DomainID returns the "domain" edge ID in the mutation.
func (m *GroupMutation) DomainID() (id int, exists bool) {
	if m.domain != nil {
		return *m.domain, true
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DomainID instead. It exists only for internal usage by the builders.
func (m *GroupMutation) DomainIDs() (ids []int) {
	if id := m.domain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *GroupMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.description != nil {
		fields = append(fields, group.FieldDescription)
	}
	if m.permissions != nil {
		fields = append(fields, group.FieldPermissions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldName:
		return m.Name()
	case group.FieldDescription:
		return m.Description()
	case group.FieldPermissions:
		return m.Permissions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldDescription:
		return m.OldDescription(ctx)
	case group.FieldPermissions:
		return m.OldPermissions(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case group.FieldPermissions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldDescription:
		m.ResetDescription()
		return nil
	case group.FieldPermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.devices != nil {
		edges = append(edges, group.EdgeDevices)
	}
	if m.users != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.domain != nil {
		edges = append(edges, group.EdgeDomain)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeDomain:
		if id := m.domain; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddevices != nil {
		edges = append(edges, group.EdgeDevices)
	}
	if m.removedusers != nil {
		edges = append(edges, group.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddevices {
		edges = append(edges, group.EdgeDevices)
	}
	if m.clearedusers {
		edges = append(edges, group.EdgeUsers)
	}
	if m.cleareddomain {
		edges = append(edges, group.EdgeDomain)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeDevices:
		return m.cleareddevices
	case group.EdgeUsers:
		return m.clearedusers
	case group.EdgeDomain:
		return m.cleareddomain
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	case group.EdgeDomain:
		m.ClearDomain()
		return nil
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeDevices:
		m.ResetDevices()
		return nil
	case group.EdgeUsers:
		m.ResetUsers()
		return nil
	case group.EdgeDomain:
		m.ResetDomain()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// LootMutation represents an operation that mutates the Loot nodes in the graph.
type LootMutation struct {
	config
	op            Op
	typ           string
	id            *int
	xid           *string
	_type         *loot.Type
	location      *string
	data          *[]byte
	collectedon   *time.Time
	clearedFields map[string]struct{}
	rodent        *int
	clearedrodent bool
	task          *int
	clearedtask   bool
	done          bool
	oldValue      func(context.Context) (*Loot, error)
	predicates    []predicate.Loot
}

var _ ent.Mutation = (*LootMutation)(nil)

// lootOption allows management of the mutation configuration using functional options.
type lootOption func(*LootMutation)

// newLootMutation creates new mutation for the Loot entity.
func newLootMutation(c config, op Op, opts ...lootOption) *LootMutation {
	m := &LootMutation{
		config:        c,
		op:            op,
		typ:           TypeLoot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLootID sets the ID field of the mutation.
func withLootID(id int) lootOption {
	return func(m *LootMutation) {
		var (
			err   error
			once  sync.Once
			value *Loot
		)
		m.oldValue = func(ctx context.Context) (*Loot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Loot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoot sets the old Loot of the mutation.
func withLoot(node *Loot) lootOption {
	return func(m *LootMutation) {
		m.oldValue = func(context.Context) (*Loot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LootMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LootMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LootMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LootMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Loot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetXid sets the "xid" field.
func (m *LootMutation) SetXid(s string) {
	m.xid = &s
}

// Xid returns the value of the "xid" field in the mutation.
func (m *LootMutation) Xid() (r string, exists bool) {
	v := m.xid
	if v == nil {
		return
	}
	return *v, true
}

// OldXid returns the old "xid" field's value of the Loot entity.
// If the Loot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LootMutation) OldXid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXid: %w", err)
	}
	return oldValue.Xid, nil
}

// ResetXid resets all changes to the "xid" field.
func (m *LootMutation) ResetXid() {
	m.xid = nil
}

// SetType sets the "type" field.
func (m *LootMutation) SetType(l loot.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LootMutation) GetType() (r loot.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Loot entity.
// If the Loot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LootMutation) OldType(ctx context.Context) (v loot.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LootMutation) ResetType() {
	m._type = nil
}

// SetLocation sets the "location" field.
func (m *LootMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *LootMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Loot entity.
// If the Loot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LootMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *LootMutation) ResetLocation() {
	m.location = nil
}

// SetData sets the "data" field.
func (m *LootMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *LootMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Loot entity.
// If the Loot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LootMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *LootMutation) ResetData() {
	m.data = nil
}

// SetCollectedon sets the "collectedon" field.
func (m *LootMutation) SetCollectedon(t time.Time) {
	m.collectedon = &t
}

// Collectedon returns the value of the "collectedon" field in the mutation.
func (m *LootMutation) Collectedon() (r time.Time, exists bool) {
	v := m.collectedon
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectedon returns the old "collectedon" field's value of the Loot entity.
// If the Loot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LootMutation) OldCollectedon(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectedon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectedon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectedon: %w", err)
	}
	return oldValue.Collectedon, nil
}

// ResetCollectedon resets all changes to the "collectedon" field.
func (m *LootMutation) ResetCollectedon() {
	m.collectedon = nil
}

// SetRodentID sets the "rodent" edge to the Rodent entity by id.
func (m *LootMutation) SetRodentID(id int) {
	m.rodent = &id
}

// ClearRodent clears the "rodent" edge to the Rodent entity.
func (m *LootMutation) ClearRodent() {
	m.clearedrodent = true
}

// RodentCleared reports if the "rodent" edge to the Rodent entity was cleared.
func (m *LootMutation) RodentCleared() bool {
	return m.clearedrodent
}

// RodentID returns the "rodent" edge ID in the mutation.
func (m *LootMutation) RodentID() (id int, exists bool) {
	if m.rodent != nil {
		return *m.rodent, true
	}
	return
}

// RodentIDs returns the "rodent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RodentID instead. It exists only for internal usage by the builders.
func (m *LootMutation) RodentIDs() (ids []int) {
	if id := m.rodent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRodent resets all changes to the "rodent" edge.
func (m *LootMutation) ResetRodent() {
	m.rodent = nil
	m.clearedrodent = false
}

// SetTaskID sets the "task" edge to the Task entity by id.
func (m *LootMutation) SetTaskID(id int) {
	m.task = &id
}

// ClearTask clears the "task" edge to the Task entity.
func (m *LootMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *LootMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskID returns the "task" edge ID in the mutation.
func (m *LootMutation) TaskID() (id int, exists bool) {
	if m.task != nil {
		return *m.task, true
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *LootMutation) TaskIDs() (ids []int) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *LootMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// Where appends a list predicates to the LootMutation builder.
func (m *LootMutation) Where(ps ...predicate.Loot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LootMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LootMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Loot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LootMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LootMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Loot).
func (m *LootMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LootMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.xid != nil {
		fields = append(fields, loot.FieldXid)
	}
	if m._type != nil {
		fields = append(fields, loot.FieldType)
	}
	if m.location != nil {
		fields = append(fields, loot.FieldLocation)
	}
	if m.data != nil {
		fields = append(fields, loot.FieldData)
	}
	if m.collectedon != nil {
		fields = append(fields, loot.FieldCollectedon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LootMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loot.FieldXid:
		return m.Xid()
	case loot.FieldType:
		return m.GetType()
	case loot.FieldLocation:
		return m.Location()
	case loot.FieldData:
		return m.Data()
	case loot.FieldCollectedon:
		return m.Collectedon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LootMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loot.FieldXid:
		return m.OldXid(ctx)
	case loot.FieldType:
		return m.OldType(ctx)
	case loot.FieldLocation:
		return m.OldLocation(ctx)
	case loot.FieldData:
		return m.OldData(ctx)
	case loot.FieldCollectedon:
		return m.OldCollectedon(ctx)
	}
	return nil, fmt.Errorf("unknown Loot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LootMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loot.FieldXid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXid(v)
		return nil
	case loot.FieldType:
		v, ok := value.(loot.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case loot.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case loot.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case loot.FieldCollectedon:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectedon(v)
		return nil
	}
	return fmt.Errorf("unknown Loot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LootMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LootMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LootMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Loot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LootMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LootMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LootMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Loot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LootMutation) ResetField(name string) error {
	switch name {
	case loot.FieldXid:
		m.ResetXid()
		return nil
	case loot.FieldType:
		m.ResetType()
		return nil
	case loot.FieldLocation:
		m.ResetLocation()
		return nil
	case loot.FieldData:
		m.ResetData()
		return nil
	case loot.FieldCollectedon:
		m.ResetCollectedon()
		return nil
	}
	return fmt.Errorf("unknown Loot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LootMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.rodent != nil {
		edges = append(edges, loot.EdgeRodent)
	}
	if m.task != nil {
		edges = append(edges, loot.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LootMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case loot.EdgeRodent:
		if id := m.rodent; id != nil {
			return []ent.Value{*id}
		}
	case loot.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LootMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LootMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LootMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrodent {
		edges = append(edges, loot.EdgeRodent)
	}
	if m.clearedtask {
		edges = append(edges, loot.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LootMutation) EdgeCleared(name string) bool {
	switch name {
	case loot.EdgeRodent:
		return m.clearedrodent
	case loot.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LootMutation) ClearEdge(name string) error {
	switch name {
	case loot.EdgeRodent:
		m.ClearRodent()
		return nil
	case loot.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown Loot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LootMutation) ResetEdge(name string) error {
	switch name {
	case loot.EdgeRodent:
		m.ResetRodent()
		return nil
	case loot.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown Loot edge %s", name)
}

// OperatorMutation represents an operation that mutates the Operator nodes in the graph.
type OperatorMutation struct {
	config
	op              Op
	typ             string
	id              *int
	username        *string
	privkey         *[]byte
	cert            *[]byte
	clearedFields   map[string]struct{}
	projects        map[int]struct{}
	removedprojects map[int]struct{}
	clearedprojects bool
	done            bool
	oldValue        func(context.Context) (*Operator, error)
	predicates      []predicate.Operator
}

var _ ent.Mutation = (*OperatorMutation)(nil)

// operatorOption allows management of the mutation configuration using functional options.
type operatorOption func(*OperatorMutation)

// newOperatorMutation creates new mutation for the Operator entity.
func newOperatorMutation(c config, op Op, opts ...operatorOption) *OperatorMutation {
	m := &OperatorMutation{
		config:        c,
		op:            op,
		typ:           TypeOperator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperatorID sets the ID field of the mutation.
func withOperatorID(id int) operatorOption {
	return func(m *OperatorMutation) {
		var (
			err   error
			once  sync.Once
			value *Operator
		)
		m.oldValue = func(ctx context.Context) (*Operator, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperator sets the old Operator of the mutation.
func withOperator(node *Operator) operatorOption {
	return func(m *OperatorMutation) {
		m.oldValue = func(context.Context) (*Operator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperatorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperatorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperatorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperatorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Operator.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *OperatorMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *OperatorMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *OperatorMutation) ResetUsername() {
	m.username = nil
}

// SetPrivkey sets the "privkey" field.
func (m *OperatorMutation) SetPrivkey(b []byte) {
	m.privkey = &b
}

// Privkey returns the value of the "privkey" field in the mutation.
func (m *OperatorMutation) Privkey() (r []byte, exists bool) {
	v := m.privkey
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivkey returns the old "privkey" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldPrivkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivkey: %w", err)
	}
	return oldValue.Privkey, nil
}

// ClearPrivkey clears the value of the "privkey" field.
func (m *OperatorMutation) ClearPrivkey() {
	m.privkey = nil
	m.clearedFields[operator.FieldPrivkey] = struct{}{}
}

// PrivkeyCleared returns if the "privkey" field was cleared in this mutation.
func (m *OperatorMutation) PrivkeyCleared() bool {
	_, ok := m.clearedFields[operator.FieldPrivkey]
	return ok
}

// ResetPrivkey resets all changes to the "privkey" field.
func (m *OperatorMutation) ResetPrivkey() {
	m.privkey = nil
	delete(m.clearedFields, operator.FieldPrivkey)
}

// SetCert sets the "cert" field.
func (m *OperatorMutation) SetCert(b []byte) {
	m.cert = &b
}

// Cert returns the value of the "cert" field in the mutation.
func (m *OperatorMutation) Cert() (r []byte, exists bool) {
	v := m.cert
	if v == nil {
		return
	}
	return *v, true
}

// OldCert returns the old "cert" field's value of the Operator entity.
// If the Operator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatorMutation) OldCert(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCert: %w", err)
	}
	return oldValue.Cert, nil
}

// ClearCert clears the value of the "cert" field.
func (m *OperatorMutation) ClearCert() {
	m.cert = nil
	m.clearedFields[operator.FieldCert] = struct{}{}
}

// CertCleared returns if the "cert" field was cleared in this mutation.
func (m *OperatorMutation) CertCleared() bool {
	_, ok := m.clearedFields[operator.FieldCert]
	return ok
}

// ResetCert resets all changes to the "cert" field.
func (m *OperatorMutation) ResetCert() {
	m.cert = nil
	delete(m.clearedFields, operator.FieldCert)
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *OperatorMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *OperatorMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *OperatorMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *OperatorMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *OperatorMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *OperatorMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *OperatorMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// Where appends a list predicates to the OperatorMutation builder.
func (m *OperatorMutation) Where(ps ...predicate.Operator) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperatorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperatorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Operator, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperatorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperatorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Operator).
func (m *OperatorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperatorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.username != nil {
		fields = append(fields, operator.FieldUsername)
	}
	if m.privkey != nil {
		fields = append(fields, operator.FieldPrivkey)
	}
	if m.cert != nil {
		fields = append(fields, operator.FieldCert)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperatorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operator.FieldUsername:
		return m.Username()
	case operator.FieldPrivkey:
		return m.Privkey()
	case operator.FieldCert:
		return m.Cert()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperatorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operator.FieldUsername:
		return m.OldUsername(ctx)
	case operator.FieldPrivkey:
		return m.OldPrivkey(ctx)
	case operator.FieldCert:
		return m.OldCert(ctx)
	}
	return nil, fmt.Errorf("unknown Operator field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operator.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case operator.FieldPrivkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivkey(v)
		return nil
	case operator.FieldCert:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCert(v)
		return nil
	}
	return fmt.Errorf("unknown Operator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperatorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperatorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Operator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperatorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(operator.FieldPrivkey) {
		fields = append(fields, operator.FieldPrivkey)
	}
	if m.FieldCleared(operator.FieldCert) {
		fields = append(fields, operator.FieldCert)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperatorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperatorMutation) ClearField(name string) error {
	switch name {
	case operator.FieldPrivkey:
		m.ClearPrivkey()
		return nil
	case operator.FieldCert:
		m.ClearCert()
		return nil
	}
	return fmt.Errorf("unknown Operator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperatorMutation) ResetField(name string) error {
	switch name {
	case operator.FieldUsername:
		m.ResetUsername()
		return nil
	case operator.FieldPrivkey:
		m.ResetPrivkey()
		return nil
	case operator.FieldCert:
		m.ResetCert()
		return nil
	}
	return fmt.Errorf("unknown Operator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperatorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.projects != nil {
		edges = append(edges, operator.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperatorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operator.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperatorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprojects != nil {
		edges = append(edges, operator.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperatorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case operator.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperatorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprojects {
		edges = append(edges, operator.EdgeProjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperatorMutation) EdgeCleared(name string) bool {
	switch name {
	case operator.EdgeProjects:
		return m.clearedprojects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperatorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Operator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperatorMutation) ResetEdge(name string) error {
	switch name {
	case operator.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown Operator edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op               Op
	typ              string
	id               *int
	clearedFields    map[string]struct{}
	operators        map[int]struct{}
	removedoperators map[int]struct{}
	clearedoperators bool
	rodents          map[int]struct{}
	removedrodents   map[int]struct{}
	clearedrodents   bool
	done             bool
	oldValue         func(context.Context) (*Project, error)
	predicates       []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddOperatorIDs adds the "operators" edge to the Operator entity by ids.
func (m *ProjectMutation) AddOperatorIDs(ids ...int) {
	if m.operators == nil {
		m.operators = make(map[int]struct{})
	}
	for i := range ids {
		m.operators[ids[i]] = struct{}{}
	}
}

// ClearOperators clears the "operators" edge to the Operator entity.
func (m *ProjectMutation) ClearOperators() {
	m.clearedoperators = true
}

// OperatorsCleared reports if the "operators" edge to the Operator entity was cleared.
func (m *ProjectMutation) OperatorsCleared() bool {
	return m.clearedoperators
}

// RemoveOperatorIDs removes the "operators" edge to the Operator entity by IDs.
func (m *ProjectMutation) RemoveOperatorIDs(ids ...int) {
	if m.removedoperators == nil {
		m.removedoperators = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.operators, ids[i])
		m.removedoperators[ids[i]] = struct{}{}
	}
}

// RemovedOperators returns the removed IDs of the "operators" edge to the Operator entity.
func (m *ProjectMutation) RemovedOperatorsIDs() (ids []int) {
	for id := range m.removedoperators {
		ids = append(ids, id)
	}
	return
}

// OperatorsIDs returns the "operators" edge IDs in the mutation.
func (m *ProjectMutation) OperatorsIDs() (ids []int) {
	for id := range m.operators {
		ids = append(ids, id)
	}
	return
}

// ResetOperators resets all changes to the "operators" edge.
func (m *ProjectMutation) ResetOperators() {
	m.operators = nil
	m.clearedoperators = false
	m.removedoperators = nil
}

// AddRodentIDs adds the "rodents" edge to the Rodent entity by ids.
func (m *ProjectMutation) AddRodentIDs(ids ...int) {
	if m.rodents == nil {
		m.rodents = make(map[int]struct{})
	}
	for i := range ids {
		m.rodents[ids[i]] = struct{}{}
	}
}

// ClearRodents clears the "rodents" edge to the Rodent entity.
func (m *ProjectMutation) ClearRodents() {
	m.clearedrodents = true
}

// RodentsCleared reports if the "rodents" edge to the Rodent entity was cleared.
func (m *ProjectMutation) RodentsCleared() bool {
	return m.clearedrodents
}

// RemoveRodentIDs removes the "rodents" edge to the Rodent entity by IDs.
func (m *ProjectMutation) RemoveRodentIDs(ids ...int) {
	if m.removedrodents == nil {
		m.removedrodents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rodents, ids[i])
		m.removedrodents[ids[i]] = struct{}{}
	}
}

// RemovedRodents returns the removed IDs of the "rodents" edge to the Rodent entity.
func (m *ProjectMutation) RemovedRodentsIDs() (ids []int) {
	for id := range m.removedrodents {
		ids = append(ids, id)
	}
	return
}

// RodentsIDs returns the "rodents" edge IDs in the mutation.
func (m *ProjectMutation) RodentsIDs() (ids []int) {
	for id := range m.rodents {
		ids = append(ids, id)
	}
	return
}

// ResetRodents resets all changes to the "rodents" edge.
func (m *ProjectMutation) ResetRodents() {
	m.rodents = nil
	m.clearedrodents = false
	m.removedrodents = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.operators != nil {
		edges = append(edges, project.EdgeOperators)
	}
	if m.rodents != nil {
		edges = append(edges, project.EdgeRodents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeOperators:
		ids := make([]ent.Value, 0, len(m.operators))
		for id := range m.operators {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRodents:
		ids := make([]ent.Value, 0, len(m.rodents))
		for id := range m.rodents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoperators != nil {
		edges = append(edges, project.EdgeOperators)
	}
	if m.removedrodents != nil {
		edges = append(edges, project.EdgeRodents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeOperators:
		ids := make([]ent.Value, 0, len(m.removedoperators))
		for id := range m.removedoperators {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRodents:
		ids := make([]ent.Value, 0, len(m.removedrodents))
		for id := range m.removedrodents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedoperators {
		edges = append(edges, project.EdgeOperators)
	}
	if m.clearedrodents {
		edges = append(edges, project.EdgeRodents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeOperators:
		return m.clearedoperators
	case project.EdgeRodents:
		return m.clearedrodents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeOperators:
		m.ResetOperators()
		return nil
	case project.EdgeRodents:
		m.ResetRodents()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// RodentMutation represents an operation that mutates the Rodent nodes in the graph.
type RodentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	xid            *string
	_type          *string
	codename       *string
	key            *string
	usercontext    *string
	beacontime     *string
	burned         *bool
	alive          *bool
	joined         *time.Time
	lastseen       *time.Time
	clearedFields  map[string]struct{}
	device         *int
	cleareddevice  bool
	user           *int
	cleareduser    bool
	project        *int
	clearedproject bool
	router         *int
	clearedrouter  bool
	tasks          map[int]struct{}
	removedtasks   map[int]struct{}
	clearedtasks   bool
	loot           map[int]struct{}
	removedloot    map[int]struct{}
	clearedloot    bool
	done           bool
	oldValue       func(context.Context) (*Rodent, error)
	predicates     []predicate.Rodent
}

var _ ent.Mutation = (*RodentMutation)(nil)

// rodentOption allows management of the mutation configuration using functional options.
type rodentOption func(*RodentMutation)

// newRodentMutation creates new mutation for the Rodent entity.
func newRodentMutation(c config, op Op, opts ...rodentOption) *RodentMutation {
	m := &RodentMutation{
		config:        c,
		op:            op,
		typ:           TypeRodent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRodentID sets the ID field of the mutation.
func withRodentID(id int) rodentOption {
	return func(m *RodentMutation) {
		var (
			err   error
			once  sync.Once
			value *Rodent
		)
		m.oldValue = func(ctx context.Context) (*Rodent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rodent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRodent sets the old Rodent of the mutation.
func withRodent(node *Rodent) rodentOption {
	return func(m *RodentMutation) {
		m.oldValue = func(context.Context) (*Rodent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RodentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RodentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RodentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RodentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rodent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetXid sets the "xid" field.
func (m *RodentMutation) SetXid(s string) {
	m.xid = &s
}

// Xid returns the value of the "xid" field in the mutation.
func (m *RodentMutation) Xid() (r string, exists bool) {
	v := m.xid
	if v == nil {
		return
	}
	return *v, true
}

// OldXid returns the old "xid" field's value of the Rodent entity.
// If the Rodent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RodentMutation) OldXid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXid: %w", err)
	}
	return oldValue.Xid, nil
}

// ResetXid resets all changes to the "xid" field.
func (m *RodentMutation) ResetXid() {
	m.xid = nil
}

// SetType sets the "type" field.
func (m *RodentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RodentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Rodent entity.
// If the Rodent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RodentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RodentMutation) ResetType() {
	m._type = nil
}

// SetCodename sets the "codename" field.
func (m *RodentMutation) SetCodename(s string) {
	m.codename = &s
}

// Codename returns the value of the "codename" field in the mutation.
func (m *RodentMutation) Codename() (r string, exists bool) {
	v := m.codename
	if v == nil {
		return
	}
	return *v, true
}

// OldCodename returns the old "codename" field's value of the Rodent entity.
// If the Rodent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RodentMutation) OldCodename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodename: %w", err)
	}
	return oldValue.Codename, nil
}

// ResetCodename resets all changes to the "codename" field.
func (m *RodentMutation) ResetCodename() {
	m.codename = nil
}

// SetKey sets the "key" field.
func (m *RodentMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *RodentMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Rodent entity.
// If the Rodent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RodentMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *RodentMutation) ResetKey() {
	m.key = nil
}

// SetUsercontext sets the "usercontext" field.
func (m *RodentMutation) SetUsercontext(s string) {
	m.usercontext = &s
}

// Usercontext returns the value of the "usercontext" field in the mutation.
func (m *RodentMutation) Usercontext() (r string, exists bool) {
	v := m.usercontext
	if v == nil {
		return
	}
	return *v, true
}

// OldUsercontext returns the old "usercontext" field's value of the Rodent entity.
// If the Rodent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RodentMutation) OldUsercontext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsercontext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsercontext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsercontext: %w", err)
	}
	return oldValue.Usercontext, nil
}

// ClearUsercontext clears the value of the "usercontext" field.
func (m *RodentMutation) ClearUsercontext() {
	m.usercontext = nil
	m.clearedFields[rodent.FieldUsercontext] = struct{}{}
}

// UsercontextCleared returns if the "usercontext" field was cleared in this mutation.
func (m *RodentMutation) UsercontextCleared() bool {
	_, ok := m.clearedFields[rodent.FieldUsercontext]
	return ok
}

// ResetUsercontext resets all changes to the "usercontext" field.
func (m *RodentMutation) ResetUsercontext() {
	m.usercontext = nil
	delete(m.clearedFields, rodent.FieldUsercontext)
}

// SetBeacontime sets the "beacontime" field.
func (m *RodentMutation) SetBeacontime(s string) {
	m.beacontime = &s
}

// Beacontime returns the value of the "beacontime" field in the mutation.
func (m *RodentMutation) Beacontime() (r string, exists bool) {
	v := m.beacontime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeacontime returns the old "beacontime" field's value of the Rodent entity.
// If the Rodent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RodentMutation) OldBeacontime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeacontime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeacontime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeacontime: %w", err)
	}
	return oldValue.Beacontime, nil
}

// ClearBeacontime clears the value of the "beacontime" field.
func (m *RodentMutation) ClearBeacontime() {
	m.beacontime = nil
	m.clearedFields[rodent.FieldBeacontime] = struct{}{}
}

// BeacontimeCleared returns if the "beacontime" field was cleared in this mutation.
func (m *RodentMutation) BeacontimeCleared() bool {
	_, ok := m.clearedFields[rodent.FieldBeacontime]
	return ok
}

// ResetBeacontime resets all changes to the "beacontime" field.
func (m *RodentMutation) ResetBeacontime() {
	m.beacontime = nil
	delete(m.clearedFields, rodent.FieldBeacontime)
}

// SetBurned sets the "burned" field.
func (m *RodentMutation) SetBurned(b bool) {
	m.burned = &b
}

// Burned returns the value of the "burned" field in the mutation.
func (m *RodentMutation) Burned() (r bool, exists bool) {
	v := m.burned
	if v == nil {
		return
	}
	return *v, true
}

// OldBurned returns the old "burned" field's value of the Rodent entity.
// If the Rodent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RodentMutation) OldBurned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBurned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBurned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBurned: %w", err)
	}
	return oldValue.Burned, nil
}

// ResetBurned resets all changes to the "burned" field.
func (m *RodentMutation) ResetBurned() {
	m.burned = nil
}

// SetAlive sets the "alive" field.
func (m *RodentMutation) SetAlive(b bool) {
	m.alive = &b
}

// Alive returns the value of the "alive" field in the mutation.
func (m *RodentMutation) Alive() (r bool, exists bool) {
	v := m.alive
	if v == nil {
		return
	}
	return *v, true
}

// OldAlive returns the old "alive" field's value of the Rodent entity.
// If the Rodent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RodentMutation) OldAlive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlive: %w", err)
	}
	return oldValue.Alive, nil
}

// ResetAlive resets all changes to the "alive" field.
func (m *RodentMutation) ResetAlive() {
	m.alive = nil
}

// SetJoined sets the "joined" field.
func (m *RodentMutation) SetJoined(t time.Time) {
	m.joined = &t
}

// Joined returns the value of the "joined" field in the mutation.
func (m *RodentMutation) Joined() (r time.Time, exists bool) {
	v := m.joined
	if v == nil {
		return
	}
	return *v, true
}

// OldJoined returns the old "joined" field's value of the Rodent entity.
// If the Rodent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RodentMutation) OldJoined(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoined is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoined requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoined: %w", err)
	}
	return oldValue.Joined, nil
}

// ResetJoined resets all changes to the "joined" field.
func (m *RodentMutation) ResetJoined() {
	m.joined = nil
}

// SetLastseen sets the "lastseen" field.
func (m *RodentMutation) SetLastseen(t time.Time) {
	m.lastseen = &t
}

// Lastseen returns the value of the "lastseen" field in the mutation.
func (m *RodentMutation) Lastseen() (r time.Time, exists bool) {
	v := m.lastseen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastseen returns the old "lastseen" field's value of the Rodent entity.
// If the Rodent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RodentMutation) OldLastseen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastseen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastseen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastseen: %w", err)
	}
	return oldValue.Lastseen, nil
}

// ResetLastseen resets all changes to the "lastseen" field.
func (m *RodentMutation) ResetLastseen() {
	m.lastseen = nil
}

// SetDeviceID sets the "device" edge to the Device entity by id.
func (m *RodentMutation) SetDeviceID(id int) {
	m.device = &id
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *RodentMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *RodentMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceID returns the "device" edge ID in the mutation.
func (m *RodentMutation) DeviceID() (id int, exists bool) {
	if m.device != nil {
		return *m.device, true
	}
	return
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *RodentMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *RodentMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *RodentMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *RodentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RodentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RodentMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RodentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RodentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *RodentMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *RodentMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *RodentMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *RodentMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *RodentMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *RodentMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetRouterID sets the "router" edge to the Router entity by id.
func (m *RodentMutation) SetRouterID(id int) {
	m.router = &id
}

// ClearRouter clears the "router" edge to the Router entity.
func (m *RodentMutation) ClearRouter() {
	m.clearedrouter = true
}

// RouterCleared reports if the "router" edge to the Router entity was cleared.
func (m *RodentMutation) RouterCleared() bool {
	return m.clearedrouter
}

// RouterID returns the "router" edge ID in the mutation.
func (m *RodentMutation) RouterID() (id int, exists bool) {
	if m.router != nil {
		return *m.router, true
	}
	return
}

// RouterIDs returns the "router" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouterID instead. It exists only for internal usage by the builders.
func (m *RodentMutation) RouterIDs() (ids []int) {
	if id := m.router; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouter resets all changes to the "router" edge.
func (m *RodentMutation) ResetRouter() {
	m.router = nil
	m.clearedrouter = false
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *RodentMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *RodentMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *RodentMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *RodentMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *RodentMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *RodentMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *RodentMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddLootIDs adds the "loot" edge to the Loot entity by ids.
func (m *RodentMutation) AddLootIDs(ids ...int) {
	if m.loot == nil {
		m.loot = make(map[int]struct{})
	}
	for i := range ids {
		m.loot[ids[i]] = struct{}{}
	}
}

// ClearLoot clears the "loot" edge to the Loot entity.
func (m *RodentMutation) ClearLoot() {
	m.clearedloot = true
}

// LootCleared reports if the "loot" edge to the Loot entity was cleared.
func (m *RodentMutation) LootCleared() bool {
	return m.clearedloot
}

// RemoveLootIDs removes the "loot" edge to the Loot entity by IDs.
func (m *RodentMutation) RemoveLootIDs(ids ...int) {
	if m.removedloot == nil {
		m.removedloot = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.loot, ids[i])
		m.removedloot[ids[i]] = struct{}{}
	}
}

// RemovedLoot returns the removed IDs of the "loot" edge to the Loot entity.
func (m *RodentMutation) RemovedLootIDs() (ids []int) {
	for id := range m.removedloot {
		ids = append(ids, id)
	}
	return
}

// LootIDs returns the "loot" edge IDs in the mutation.
func (m *RodentMutation) LootIDs() (ids []int) {
	for id := range m.loot {
		ids = append(ids, id)
	}
	return
}

// ResetLoot resets all changes to the "loot" edge.
func (m *RodentMutation) ResetLoot() {
	m.loot = nil
	m.clearedloot = false
	m.removedloot = nil
}

// Where appends a list predicates to the RodentMutation builder.
func (m *RodentMutation) Where(ps ...predicate.Rodent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RodentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RodentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Rodent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RodentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RodentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Rodent).
func (m *RodentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RodentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.xid != nil {
		fields = append(fields, rodent.FieldXid)
	}
	if m._type != nil {
		fields = append(fields, rodent.FieldType)
	}
	if m.codename != nil {
		fields = append(fields, rodent.FieldCodename)
	}
	if m.key != nil {
		fields = append(fields, rodent.FieldKey)
	}
	if m.usercontext != nil {
		fields = append(fields, rodent.FieldUsercontext)
	}
	if m.beacontime != nil {
		fields = append(fields, rodent.FieldBeacontime)
	}
	if m.burned != nil {
		fields = append(fields, rodent.FieldBurned)
	}
	if m.alive != nil {
		fields = append(fields, rodent.FieldAlive)
	}
	if m.joined != nil {
		fields = append(fields, rodent.FieldJoined)
	}
	if m.lastseen != nil {
		fields = append(fields, rodent.FieldLastseen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RodentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rodent.FieldXid:
		return m.Xid()
	case rodent.FieldType:
		return m.GetType()
	case rodent.FieldCodename:
		return m.Codename()
	case rodent.FieldKey:
		return m.Key()
	case rodent.FieldUsercontext:
		return m.Usercontext()
	case rodent.FieldBeacontime:
		return m.Beacontime()
	case rodent.FieldBurned:
		return m.Burned()
	case rodent.FieldAlive:
		return m.Alive()
	case rodent.FieldJoined:
		return m.Joined()
	case rodent.FieldLastseen:
		return m.Lastseen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RodentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rodent.FieldXid:
		return m.OldXid(ctx)
	case rodent.FieldType:
		return m.OldType(ctx)
	case rodent.FieldCodename:
		return m.OldCodename(ctx)
	case rodent.FieldKey:
		return m.OldKey(ctx)
	case rodent.FieldUsercontext:
		return m.OldUsercontext(ctx)
	case rodent.FieldBeacontime:
		return m.OldBeacontime(ctx)
	case rodent.FieldBurned:
		return m.OldBurned(ctx)
	case rodent.FieldAlive:
		return m.OldAlive(ctx)
	case rodent.FieldJoined:
		return m.OldJoined(ctx)
	case rodent.FieldLastseen:
		return m.OldLastseen(ctx)
	}
	return nil, fmt.Errorf("unknown Rodent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RodentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rodent.FieldXid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXid(v)
		return nil
	case rodent.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case rodent.FieldCodename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodename(v)
		return nil
	case rodent.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case rodent.FieldUsercontext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsercontext(v)
		return nil
	case rodent.FieldBeacontime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeacontime(v)
		return nil
	case rodent.FieldBurned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBurned(v)
		return nil
	case rodent.FieldAlive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlive(v)
		return nil
	case rodent.FieldJoined:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoined(v)
		return nil
	case rodent.FieldLastseen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastseen(v)
		return nil
	}
	return fmt.Errorf("unknown Rodent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RodentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RodentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RodentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Rodent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RodentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rodent.FieldUsercontext) {
		fields = append(fields, rodent.FieldUsercontext)
	}
	if m.FieldCleared(rodent.FieldBeacontime) {
		fields = append(fields, rodent.FieldBeacontime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RodentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RodentMutation) ClearField(name string) error {
	switch name {
	case rodent.FieldUsercontext:
		m.ClearUsercontext()
		return nil
	case rodent.FieldBeacontime:
		m.ClearBeacontime()
		return nil
	}
	return fmt.Errorf("unknown Rodent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RodentMutation) ResetField(name string) error {
	switch name {
	case rodent.FieldXid:
		m.ResetXid()
		return nil
	case rodent.FieldType:
		m.ResetType()
		return nil
	case rodent.FieldCodename:
		m.ResetCodename()
		return nil
	case rodent.FieldKey:
		m.ResetKey()
		return nil
	case rodent.FieldUsercontext:
		m.ResetUsercontext()
		return nil
	case rodent.FieldBeacontime:
		m.ResetBeacontime()
		return nil
	case rodent.FieldBurned:
		m.ResetBurned()
		return nil
	case rodent.FieldAlive:
		m.ResetAlive()
		return nil
	case rodent.FieldJoined:
		m.ResetJoined()
		return nil
	case rodent.FieldLastseen:
		m.ResetLastseen()
		return nil
	}
	return fmt.Errorf("unknown Rodent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RodentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.device != nil {
		edges = append(edges, rodent.EdgeDevice)
	}
	if m.user != nil {
		edges = append(edges, rodent.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, rodent.EdgeProject)
	}
	if m.router != nil {
		edges = append(edges, rodent.EdgeRouter)
	}
	if m.tasks != nil {
		edges = append(edges, rodent.EdgeTasks)
	}
	if m.loot != nil {
		edges = append(edges, rodent.EdgeLoot)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RodentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rodent.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case rodent.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case rodent.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case rodent.EdgeRouter:
		if id := m.router; id != nil {
			return []ent.Value{*id}
		}
	case rodent.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case rodent.EdgeLoot:
		ids := make([]ent.Value, 0, len(m.loot))
		for id := range m.loot {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RodentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtasks != nil {
		edges = append(edges, rodent.EdgeTasks)
	}
	if m.removedloot != nil {
		edges = append(edges, rodent.EdgeLoot)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RodentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rodent.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case rodent.EdgeLoot:
		ids := make([]ent.Value, 0, len(m.removedloot))
		for id := range m.removedloot {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RodentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareddevice {
		edges = append(edges, rodent.EdgeDevice)
	}
	if m.cleareduser {
		edges = append(edges, rodent.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, rodent.EdgeProject)
	}
	if m.clearedrouter {
		edges = append(edges, rodent.EdgeRouter)
	}
	if m.clearedtasks {
		edges = append(edges, rodent.EdgeTasks)
	}
	if m.clearedloot {
		edges = append(edges, rodent.EdgeLoot)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RodentMutation) EdgeCleared(name string) bool {
	switch name {
	case rodent.EdgeDevice:
		return m.cleareddevice
	case rodent.EdgeUser:
		return m.cleareduser
	case rodent.EdgeProject:
		return m.clearedproject
	case rodent.EdgeRouter:
		return m.clearedrouter
	case rodent.EdgeTasks:
		return m.clearedtasks
	case rodent.EdgeLoot:
		return m.clearedloot
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RodentMutation) ClearEdge(name string) error {
	switch name {
	case rodent.EdgeDevice:
		m.ClearDevice()
		return nil
	case rodent.EdgeUser:
		m.ClearUser()
		return nil
	case rodent.EdgeProject:
		m.ClearProject()
		return nil
	case rodent.EdgeRouter:
		m.ClearRouter()
		return nil
	}
	return fmt.Errorf("unknown Rodent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RodentMutation) ResetEdge(name string) error {
	switch name {
	case rodent.EdgeDevice:
		m.ResetDevice()
		return nil
	case rodent.EdgeUser:
		m.ResetUser()
		return nil
	case rodent.EdgeProject:
		m.ResetProject()
		return nil
	case rodent.EdgeRouter:
		m.ResetRouter()
		return nil
	case rodent.EdgeTasks:
		m.ResetTasks()
		return nil
	case rodent.EdgeLoot:
		m.ResetLoot()
		return nil
	}
	return fmt.Errorf("unknown Rodent edge %s", name)
}

// RouterMutation represents an operation that mutates the Router nodes in the graph.
type RouterMutation struct {
	config
	op             Op
	typ            string
	id             *int
	username       *string
	privkey        *[]byte
	cert           *[]byte
	commands       *[]string
	appendcommands []string
	clearedFields  map[string]struct{}
	rodents        map[int]struct{}
	removedrodents map[int]struct{}
	clearedrodents bool
	done           bool
	oldValue       func(context.Context) (*Router, error)
	predicates     []predicate.Router
}

var _ ent.Mutation = (*RouterMutation)(nil)

// routerOption allows management of the mutation configuration using functional options.
type routerOption func(*RouterMutation)

// newRouterMutation creates new mutation for the Router entity.
func newRouterMutation(c config, op Op, opts ...routerOption) *RouterMutation {
	m := &RouterMutation{
		config:        c,
		op:            op,
		typ:           TypeRouter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouterID sets the ID field of the mutation.
func withRouterID(id int) routerOption {
	return func(m *RouterMutation) {
		var (
			err   error
			once  sync.Once
			value *Router
		)
		m.oldValue = func(ctx context.Context) (*Router, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Router.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouter sets the old Router of the mutation.
func withRouter(node *Router) routerOption {
	return func(m *RouterMutation) {
		m.oldValue = func(context.Context) (*Router, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Router.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *RouterMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *RouterMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *RouterMutation) ResetUsername() {
	m.username = nil
}

// SetPrivkey sets the "privkey" field.
func (m *RouterMutation) SetPrivkey(b []byte) {
	m.privkey = &b
}

// Privkey returns the value of the "privkey" field in the mutation.
func (m *RouterMutation) Privkey() (r []byte, exists bool) {
	v := m.privkey
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivkey returns the old "privkey" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldPrivkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivkey: %w", err)
	}
	return oldValue.Privkey, nil
}

// ClearPrivkey clears the value of the "privkey" field.
func (m *RouterMutation) ClearPrivkey() {
	m.privkey = nil
	m.clearedFields[router.FieldPrivkey] = struct{}{}
}

// PrivkeyCleared returns if the "privkey" field was cleared in this mutation.
func (m *RouterMutation) PrivkeyCleared() bool {
	_, ok := m.clearedFields[router.FieldPrivkey]
	return ok
}

// ResetPrivkey resets all changes to the "privkey" field.
func (m *RouterMutation) ResetPrivkey() {
	m.privkey = nil
	delete(m.clearedFields, router.FieldPrivkey)
}

// SetCert sets the "cert" field.
func (m *RouterMutation) SetCert(b []byte) {
	m.cert = &b
}

// Cert returns the value of the "cert" field in the mutation.
func (m *RouterMutation) Cert() (r []byte, exists bool) {
	v := m.cert
	if v == nil {
		return
	}
	return *v, true
}

// OldCert returns the old "cert" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldCert(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCert: %w", err)
	}
	return oldValue.Cert, nil
}

// ClearCert clears the value of the "cert" field.
func (m *RouterMutation) ClearCert() {
	m.cert = nil
	m.clearedFields[router.FieldCert] = struct{}{}
}

// CertCleared returns if the "cert" field was cleared in this mutation.
func (m *RouterMutation) CertCleared() bool {
	_, ok := m.clearedFields[router.FieldCert]
	return ok
}

// ResetCert resets all changes to the "cert" field.
func (m *RouterMutation) ResetCert() {
	m.cert = nil
	delete(m.clearedFields, router.FieldCert)
}

// SetCommands sets the "commands" field.
func (m *RouterMutation) SetCommands(s []string) {
	m.commands = &s
	m.appendcommands = nil
}

// Commands returns the value of the "commands" field in the mutation.
func (m *RouterMutation) Commands() (r []string, exists bool) {
	v := m.commands
	if v == nil {
		return
	}
	return *v, true
}

// OldCommands returns the old "commands" field's value of the Router entity.
// If the Router object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouterMutation) OldCommands(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommands is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommands requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommands: %w", err)
	}
	return oldValue.Commands, nil
}

// AppendCommands adds s to the "commands" field.
func (m *RouterMutation) AppendCommands(s []string) {
	m.appendcommands = append(m.appendcommands, s...)
}

// AppendedCommands returns the list of values that were appended to the "commands" field in this mutation.
func (m *RouterMutation) AppendedCommands() ([]string, bool) {
	if len(m.appendcommands) == 0 {
		return nil, false
	}
	return m.appendcommands, true
}

// ClearCommands clears the value of the "commands" field.
func (m *RouterMutation) ClearCommands() {
	m.commands = nil
	m.appendcommands = nil
	m.clearedFields[router.FieldCommands] = struct{}{}
}

// CommandsCleared returns if the "commands" field was cleared in this mutation.
func (m *RouterMutation) CommandsCleared() bool {
	_, ok := m.clearedFields[router.FieldCommands]
	return ok
}

// ResetCommands resets all changes to the "commands" field.
func (m *RouterMutation) ResetCommands() {
	m.commands = nil
	m.appendcommands = nil
	delete(m.clearedFields, router.FieldCommands)
}

// AddRodentIDs adds the "rodents" edge to the Rodent entity by ids.
func (m *RouterMutation) AddRodentIDs(ids ...int) {
	if m.rodents == nil {
		m.rodents = make(map[int]struct{})
	}
	for i := range ids {
		m.rodents[ids[i]] = struct{}{}
	}
}

// ClearRodents clears the "rodents" edge to the Rodent entity.
func (m *RouterMutation) ClearRodents() {
	m.clearedrodents = true
}

// RodentsCleared reports if the "rodents" edge to the Rodent entity was cleared.
func (m *RouterMutation) RodentsCleared() bool {
	return m.clearedrodents
}

// RemoveRodentIDs removes the "rodents" edge to the Rodent entity by IDs.
func (m *RouterMutation) RemoveRodentIDs(ids ...int) {
	if m.removedrodents == nil {
		m.removedrodents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rodents, ids[i])
		m.removedrodents[ids[i]] = struct{}{}
	}
}

// RemovedRodents returns the removed IDs of the "rodents" edge to the Rodent entity.
func (m *RouterMutation) RemovedRodentsIDs() (ids []int) {
	for id := range m.removedrodents {
		ids = append(ids, id)
	}
	return
}

// RodentsIDs returns the "rodents" edge IDs in the mutation.
func (m *RouterMutation) RodentsIDs() (ids []int) {
	for id := range m.rodents {
		ids = append(ids, id)
	}
	return
}

// ResetRodents resets all changes to the "rodents" edge.
func (m *RouterMutation) ResetRodents() {
	m.rodents = nil
	m.clearedrodents = false
	m.removedrodents = nil
}

// Where appends a list predicates to the RouterMutation builder.
func (m *RouterMutation) Where(ps ...predicate.Router) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Router, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Router).
func (m *RouterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouterMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.username != nil {
		fields = append(fields, router.FieldUsername)
	}
	if m.privkey != nil {
		fields = append(fields, router.FieldPrivkey)
	}
	if m.cert != nil {
		fields = append(fields, router.FieldCert)
	}
	if m.commands != nil {
		fields = append(fields, router.FieldCommands)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case router.FieldUsername:
		return m.Username()
	case router.FieldPrivkey:
		return m.Privkey()
	case router.FieldCert:
		return m.Cert()
	case router.FieldCommands:
		return m.Commands()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case router.FieldUsername:
		return m.OldUsername(ctx)
	case router.FieldPrivkey:
		return m.OldPrivkey(ctx)
	case router.FieldCert:
		return m.OldCert(ctx)
	case router.FieldCommands:
		return m.OldCommands(ctx)
	}
	return nil, fmt.Errorf("unknown Router field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case router.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case router.FieldPrivkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivkey(v)
		return nil
	case router.FieldCert:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCert(v)
		return nil
	case router.FieldCommands:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommands(v)
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Router numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(router.FieldPrivkey) {
		fields = append(fields, router.FieldPrivkey)
	}
	if m.FieldCleared(router.FieldCert) {
		fields = append(fields, router.FieldCert)
	}
	if m.FieldCleared(router.FieldCommands) {
		fields = append(fields, router.FieldCommands)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouterMutation) ClearField(name string) error {
	switch name {
	case router.FieldPrivkey:
		m.ClearPrivkey()
		return nil
	case router.FieldCert:
		m.ClearCert()
		return nil
	case router.FieldCommands:
		m.ClearCommands()
		return nil
	}
	return fmt.Errorf("unknown Router nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouterMutation) ResetField(name string) error {
	switch name {
	case router.FieldUsername:
		m.ResetUsername()
		return nil
	case router.FieldPrivkey:
		m.ResetPrivkey()
		return nil
	case router.FieldCert:
		m.ResetCert()
		return nil
	case router.FieldCommands:
		m.ResetCommands()
		return nil
	}
	return fmt.Errorf("unknown Router field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rodents != nil {
		edges = append(edges, router.EdgeRodents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case router.EdgeRodents:
		ids := make([]ent.Value, 0, len(m.rodents))
		for id := range m.rodents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrodents != nil {
		edges = append(edges, router.EdgeRodents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case router.EdgeRodents:
		ids := make([]ent.Value, 0, len(m.removedrodents))
		for id := range m.removedrodents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrodents {
		edges = append(edges, router.EdgeRodents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouterMutation) EdgeCleared(name string) bool {
	switch name {
	case router.EdgeRodents:
		return m.clearedrodents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Router unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouterMutation) ResetEdge(name string) error {
	switch name {
	case router.EdgeRodents:
		m.ResetRodents()
		return nil
	}
	return fmt.Errorf("unknown Router edge %s", name)
}

// SubnetMutation represents an operation that mutates the Subnet nodes in the graph.
type SubnetMutation struct {
	config
	op            Op
	typ           string
	id            *int
	cidr          *string
	mask          *[]byte
	clearedFields map[string]struct{}
	hosts         map[int]struct{}
	removedhosts  map[int]struct{}
	clearedhosts  bool
	done          bool
	oldValue      func(context.Context) (*Subnet, error)
	predicates    []predicate.Subnet
}

var _ ent.Mutation = (*SubnetMutation)(nil)

// subnetOption allows management of the mutation configuration using functional options.
type subnetOption func(*SubnetMutation)

// newSubnetMutation creates new mutation for the Subnet entity.
func newSubnetMutation(c config, op Op, opts ...subnetOption) *SubnetMutation {
	m := &SubnetMutation{
		config:        c,
		op:            op,
		typ:           TypeSubnet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubnetID sets the ID field of the mutation.
func withSubnetID(id int) subnetOption {
	return func(m *SubnetMutation) {
		var (
			err   error
			once  sync.Once
			value *Subnet
		)
		m.oldValue = func(ctx context.Context) (*Subnet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subnet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubnet sets the old Subnet of the mutation.
func withSubnet(node *Subnet) subnetOption {
	return func(m *SubnetMutation) {
		m.oldValue = func(context.Context) (*Subnet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubnetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubnetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubnetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubnetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subnet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCidr sets the "cidr" field.
func (m *SubnetMutation) SetCidr(s string) {
	m.cidr = &s
}

// Cidr returns the value of the "cidr" field in the mutation.
func (m *SubnetMutation) Cidr() (r string, exists bool) {
	v := m.cidr
	if v == nil {
		return
	}
	return *v, true
}

// OldCidr returns the old "cidr" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldCidr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCidr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCidr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidr: %w", err)
	}
	return oldValue.Cidr, nil
}

// ResetCidr resets all changes to the "cidr" field.
func (m *SubnetMutation) ResetCidr() {
	m.cidr = nil
}

// SetMask sets the "mask" field.
func (m *SubnetMutation) SetMask(b []byte) {
	m.mask = &b
}

// Mask returns the value of the "mask" field in the mutation.
func (m *SubnetMutation) Mask() (r []byte, exists bool) {
	v := m.mask
	if v == nil {
		return
	}
	return *v, true
}

// OldMask returns the old "mask" field's value of the Subnet entity.
// If the Subnet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubnetMutation) OldMask(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMask: %w", err)
	}
	return oldValue.Mask, nil
}

// ClearMask clears the value of the "mask" field.
func (m *SubnetMutation) ClearMask() {
	m.mask = nil
	m.clearedFields[subnet.FieldMask] = struct{}{}
}

// MaskCleared returns if the "mask" field was cleared in this mutation.
func (m *SubnetMutation) MaskCleared() bool {
	_, ok := m.clearedFields[subnet.FieldMask]
	return ok
}

// ResetMask resets all changes to the "mask" field.
func (m *SubnetMutation) ResetMask() {
	m.mask = nil
	delete(m.clearedFields, subnet.FieldMask)
}

// AddHostIDs adds the "hosts" edge to the Device entity by ids.
func (m *SubnetMutation) AddHostIDs(ids ...int) {
	if m.hosts == nil {
		m.hosts = make(map[int]struct{})
	}
	for i := range ids {
		m.hosts[ids[i]] = struct{}{}
	}
}

// ClearHosts clears the "hosts" edge to the Device entity.
func (m *SubnetMutation) ClearHosts() {
	m.clearedhosts = true
}

// HostsCleared reports if the "hosts" edge to the Device entity was cleared.
func (m *SubnetMutation) HostsCleared() bool {
	return m.clearedhosts
}

// RemoveHostIDs removes the "hosts" edge to the Device entity by IDs.
func (m *SubnetMutation) RemoveHostIDs(ids ...int) {
	if m.removedhosts == nil {
		m.removedhosts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hosts, ids[i])
		m.removedhosts[ids[i]] = struct{}{}
	}
}

// RemovedHosts returns the removed IDs of the "hosts" edge to the Device entity.
func (m *SubnetMutation) RemovedHostsIDs() (ids []int) {
	for id := range m.removedhosts {
		ids = append(ids, id)
	}
	return
}

// HostsIDs returns the "hosts" edge IDs in the mutation.
func (m *SubnetMutation) HostsIDs() (ids []int) {
	for id := range m.hosts {
		ids = append(ids, id)
	}
	return
}

// ResetHosts resets all changes to the "hosts" edge.
func (m *SubnetMutation) ResetHosts() {
	m.hosts = nil
	m.clearedhosts = false
	m.removedhosts = nil
}

// Where appends a list predicates to the SubnetMutation builder.
func (m *SubnetMutation) Where(ps ...predicate.Subnet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubnetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubnetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subnet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubnetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubnetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subnet).
func (m *SubnetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubnetMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.cidr != nil {
		fields = append(fields, subnet.FieldCidr)
	}
	if m.mask != nil {
		fields = append(fields, subnet.FieldMask)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubnetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subnet.FieldCidr:
		return m.Cidr()
	case subnet.FieldMask:
		return m.Mask()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubnetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subnet.FieldCidr:
		return m.OldCidr(ctx)
	case subnet.FieldMask:
		return m.OldMask(ctx)
	}
	return nil, fmt.Errorf("unknown Subnet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubnetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subnet.FieldCidr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidr(v)
		return nil
	case subnet.FieldMask:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMask(v)
		return nil
	}
	return fmt.Errorf("unknown Subnet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubnetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubnetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubnetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subnet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubnetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subnet.FieldMask) {
		fields = append(fields, subnet.FieldMask)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubnetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubnetMutation) ClearField(name string) error {
	switch name {
	case subnet.FieldMask:
		m.ClearMask()
		return nil
	}
	return fmt.Errorf("unknown Subnet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubnetMutation) ResetField(name string) error {
	switch name {
	case subnet.FieldCidr:
		m.ResetCidr()
		return nil
	case subnet.FieldMask:
		m.ResetMask()
		return nil
	}
	return fmt.Errorf("unknown Subnet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubnetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hosts != nil {
		edges = append(edges, subnet.EdgeHosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubnetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subnet.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.hosts))
		for id := range m.hosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubnetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhosts != nil {
		edges = append(edges, subnet.EdgeHosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubnetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subnet.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.removedhosts))
		for id := range m.removedhosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubnetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhosts {
		edges = append(edges, subnet.EdgeHosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubnetMutation) EdgeCleared(name string) bool {
	switch name {
	case subnet.EdgeHosts:
		return m.clearedhosts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubnetMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subnet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubnetMutation) ResetEdge(name string) error {
	switch name {
	case subnet.EdgeHosts:
		m.ResetHosts()
		return nil
	}
	return fmt.Errorf("unknown Subnet edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op            Op
	typ           string
	id            *int
	xid           *string
	_type         *string
	args          *[]string
	appendargs    []string
	data          *[]byte
	result        *[]byte
	_Executed     *bool
	looted        *bool
	requestedat   *time.Time
	completedat   *time.Time
	_TTPs         *[]string
	append_TTPs   []string
	clearedFields map[string]struct{}
	rodent        *int
	clearedrodent bool
	loot          map[int]struct{}
	removedloot   map[int]struct{}
	clearedloot   bool
	done          bool
	oldValue      func(context.Context) (*Task, error)
	predicates    []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetXid sets the "xid" field.
func (m *TaskMutation) SetXid(s string) {
	m.xid = &s
}

// Xid returns the value of the "xid" field in the mutation.
func (m *TaskMutation) Xid() (r string, exists bool) {
	v := m.xid
	if v == nil {
		return
	}
	return *v, true
}

// OldXid returns the old "xid" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldXid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXid: %w", err)
	}
	return oldValue.Xid, nil
}

// ResetXid resets all changes to the "xid" field.
func (m *TaskMutation) ResetXid() {
	m.xid = nil
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
}

// SetArgs sets the "args" field.
func (m *TaskMutation) SetArgs(s []string) {
	m.args = &s
	m.appendargs = nil
}

// Args returns the value of the "args" field in the mutation.
func (m *TaskMutation) Args() (r []string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldArgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// AppendArgs adds s to the "args" field.
func (m *TaskMutation) AppendArgs(s []string) {
	m.appendargs = append(m.appendargs, s...)
}

// AppendedArgs returns the list of values that were appended to the "args" field in this mutation.
func (m *TaskMutation) AppendedArgs() ([]string, bool) {
	if len(m.appendargs) == 0 {
		return nil, false
	}
	return m.appendargs, true
}

// ClearArgs clears the value of the "args" field.
func (m *TaskMutation) ClearArgs() {
	m.args = nil
	m.appendargs = nil
	m.clearedFields[task.FieldArgs] = struct{}{}
}

// ArgsCleared returns if the "args" field was cleared in this mutation.
func (m *TaskMutation) ArgsCleared() bool {
	_, ok := m.clearedFields[task.FieldArgs]
	return ok
}

// ResetArgs resets all changes to the "args" field.
func (m *TaskMutation) ResetArgs() {
	m.args = nil
	m.appendargs = nil
	delete(m.clearedFields, task.FieldArgs)
}

// SetData sets the "data" field.
func (m *TaskMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *TaskMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *TaskMutation) ClearData() {
	m.data = nil
	m.clearedFields[task.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *TaskMutation) DataCleared() bool {
	_, ok := m.clearedFields[task.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *TaskMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, task.FieldData)
}

// SetResult sets the "result" field.
func (m *TaskMutation) SetResult(b []byte) {
	m.result = &b
}

// Result returns the value of the "result" field in the mutation.
func (m *TaskMutation) Result() (r []byte, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldResult(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *TaskMutation) ClearResult() {
	m.result = nil
	m.clearedFields[task.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *TaskMutation) ResultCleared() bool {
	_, ok := m.clearedFields[task.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *TaskMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, task.FieldResult)
}

// SetExecuted sets the "Executed" field.
func (m *TaskMutation) SetExecuted(b bool) {
	m._Executed = &b
}

// Executed returns the value of the "Executed" field in the mutation.
func (m *TaskMutation) Executed() (r bool, exists bool) {
	v := m._Executed
	if v == nil {
		return
	}
	return *v, true
}

// OldExecuted returns the old "Executed" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldExecuted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecuted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecuted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecuted: %w", err)
	}
	return oldValue.Executed, nil
}

// ResetExecuted resets all changes to the "Executed" field.
func (m *TaskMutation) ResetExecuted() {
	m._Executed = nil
}

// SetLooted sets the "looted" field.
func (m *TaskMutation) SetLooted(b bool) {
	m.looted = &b
}

// Looted returns the value of the "looted" field in the mutation.
func (m *TaskMutation) Looted() (r bool, exists bool) {
	v := m.looted
	if v == nil {
		return
	}
	return *v, true
}

// OldLooted returns the old "looted" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLooted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLooted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLooted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLooted: %w", err)
	}
	return oldValue.Looted, nil
}

// ResetLooted resets all changes to the "looted" field.
func (m *TaskMutation) ResetLooted() {
	m.looted = nil
}

// SetRequestedat sets the "requestedat" field.
func (m *TaskMutation) SetRequestedat(t time.Time) {
	m.requestedat = &t
}

// Requestedat returns the value of the "requestedat" field in the mutation.
func (m *TaskMutation) Requestedat() (r time.Time, exists bool) {
	v := m.requestedat
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedat returns the old "requestedat" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRequestedat(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedat: %w", err)
	}
	return oldValue.Requestedat, nil
}

// ResetRequestedat resets all changes to the "requestedat" field.
func (m *TaskMutation) ResetRequestedat() {
	m.requestedat = nil
}

// SetCompletedat sets the "completedat" field.
func (m *TaskMutation) SetCompletedat(t time.Time) {
	m.completedat = &t
}

// Completedat returns the value of the "completedat" field in the mutation.
func (m *TaskMutation) Completedat() (r time.Time, exists bool) {
	v := m.completedat
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedat returns the old "completedat" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCompletedat(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedat: %w", err)
	}
	return oldValue.Completedat, nil
}

// ClearCompletedat clears the value of the "completedat" field.
func (m *TaskMutation) ClearCompletedat() {
	m.completedat = nil
	m.clearedFields[task.FieldCompletedat] = struct{}{}
}

// CompletedatCleared returns if the "completedat" field was cleared in this mutation.
func (m *TaskMutation) CompletedatCleared() bool {
	_, ok := m.clearedFields[task.FieldCompletedat]
	return ok
}

// ResetCompletedat resets all changes to the "completedat" field.
func (m *TaskMutation) ResetCompletedat() {
	m.completedat = nil
	delete(m.clearedFields, task.FieldCompletedat)
}

// SetTTPs sets the "TTPs" field.
func (m *TaskMutation) SetTTPs(s []string) {
	m._TTPs = &s
	m.append_TTPs = nil
}

// TTPs returns the value of the "TTPs" field in the mutation.
func (m *TaskMutation) TTPs() (r []string, exists bool) {
	v := m._TTPs
	if v == nil {
		return
	}
	return *v, true
}

// OldTTPs returns the old "TTPs" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTTPs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTTPs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTTPs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTTPs: %w", err)
	}
	return oldValue.TTPs, nil
}

// AppendTTPs adds s to the "TTPs" field.
func (m *TaskMutation) AppendTTPs(s []string) {
	m.append_TTPs = append(m.append_TTPs, s...)
}

// AppendedTTPs returns the list of values that were appended to the "TTPs" field in this mutation.
func (m *TaskMutation) AppendedTTPs() ([]string, bool) {
	if len(m.append_TTPs) == 0 {
		return nil, false
	}
	return m.append_TTPs, true
}

// ClearTTPs clears the value of the "TTPs" field.
func (m *TaskMutation) ClearTTPs() {
	m._TTPs = nil
	m.append_TTPs = nil
	m.clearedFields[task.FieldTTPs] = struct{}{}
}

// TTPsCleared returns if the "TTPs" field was cleared in this mutation.
func (m *TaskMutation) TTPsCleared() bool {
	_, ok := m.clearedFields[task.FieldTTPs]
	return ok
}

// ResetTTPs resets all changes to the "TTPs" field.
func (m *TaskMutation) ResetTTPs() {
	m._TTPs = nil
	m.append_TTPs = nil
	delete(m.clearedFields, task.FieldTTPs)
}

// SetRodentID sets the "rodent" edge to the Rodent entity by id.
func (m *TaskMutation) SetRodentID(id int) {
	m.rodent = &id
}

// ClearRodent clears the "rodent" edge to the Rodent entity.
func (m *TaskMutation) ClearRodent() {
	m.clearedrodent = true
}

// RodentCleared reports if the "rodent" edge to the Rodent entity was cleared.
func (m *TaskMutation) RodentCleared() bool {
	return m.clearedrodent
}

// RodentID returns the "rodent" edge ID in the mutation.
func (m *TaskMutation) RodentID() (id int, exists bool) {
	if m.rodent != nil {
		return *m.rodent, true
	}
	return
}

// RodentIDs returns the "rodent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RodentID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) RodentIDs() (ids []int) {
	if id := m.rodent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRodent resets all changes to the "rodent" edge.
func (m *TaskMutation) ResetRodent() {
	m.rodent = nil
	m.clearedrodent = false
}

// AddLootIDs adds the "loot" edge to the Loot entity by ids.
func (m *TaskMutation) AddLootIDs(ids ...int) {
	if m.loot == nil {
		m.loot = make(map[int]struct{})
	}
	for i := range ids {
		m.loot[ids[i]] = struct{}{}
	}
}

// ClearLoot clears the "loot" edge to the Loot entity.
func (m *TaskMutation) ClearLoot() {
	m.clearedloot = true
}

// LootCleared reports if the "loot" edge to the Loot entity was cleared.
func (m *TaskMutation) LootCleared() bool {
	return m.clearedloot
}

// RemoveLootIDs removes the "loot" edge to the Loot entity by IDs.
func (m *TaskMutation) RemoveLootIDs(ids ...int) {
	if m.removedloot == nil {
		m.removedloot = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.loot, ids[i])
		m.removedloot[ids[i]] = struct{}{}
	}
}

// RemovedLoot returns the removed IDs of the "loot" edge to the Loot entity.
func (m *TaskMutation) RemovedLootIDs() (ids []int) {
	for id := range m.removedloot {
		ids = append(ids, id)
	}
	return
}

// LootIDs returns the "loot" edge IDs in the mutation.
func (m *TaskMutation) LootIDs() (ids []int) {
	for id := range m.loot {
		ids = append(ids, id)
	}
	return
}

// ResetLoot resets all changes to the "loot" edge.
func (m *TaskMutation) ResetLoot() {
	m.loot = nil
	m.clearedloot = false
	m.removedloot = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.xid != nil {
		fields = append(fields, task.FieldXid)
	}
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.args != nil {
		fields = append(fields, task.FieldArgs)
	}
	if m.data != nil {
		fields = append(fields, task.FieldData)
	}
	if m.result != nil {
		fields = append(fields, task.FieldResult)
	}
	if m._Executed != nil {
		fields = append(fields, task.FieldExecuted)
	}
	if m.looted != nil {
		fields = append(fields, task.FieldLooted)
	}
	if m.requestedat != nil {
		fields = append(fields, task.FieldRequestedat)
	}
	if m.completedat != nil {
		fields = append(fields, task.FieldCompletedat)
	}
	if m._TTPs != nil {
		fields = append(fields, task.FieldTTPs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldXid:
		return m.Xid()
	case task.FieldType:
		return m.GetType()
	case task.FieldArgs:
		return m.Args()
	case task.FieldData:
		return m.Data()
	case task.FieldResult:
		return m.Result()
	case task.FieldExecuted:
		return m.Executed()
	case task.FieldLooted:
		return m.Looted()
	case task.FieldRequestedat:
		return m.Requestedat()
	case task.FieldCompletedat:
		return m.Completedat()
	case task.FieldTTPs:
		return m.TTPs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldXid:
		return m.OldXid(ctx)
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldArgs:
		return m.OldArgs(ctx)
	case task.FieldData:
		return m.OldData(ctx)
	case task.FieldResult:
		return m.OldResult(ctx)
	case task.FieldExecuted:
		return m.OldExecuted(ctx)
	case task.FieldLooted:
		return m.OldLooted(ctx)
	case task.FieldRequestedat:
		return m.OldRequestedat(ctx)
	case task.FieldCompletedat:
		return m.OldCompletedat(ctx)
	case task.FieldTTPs:
		return m.OldTTPs(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldXid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXid(v)
		return nil
	case task.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldArgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case task.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case task.FieldResult:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case task.FieldExecuted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecuted(v)
		return nil
	case task.FieldLooted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLooted(v)
		return nil
	case task.FieldRequestedat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedat(v)
		return nil
	case task.FieldCompletedat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedat(v)
		return nil
	case task.FieldTTPs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTTPs(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldArgs) {
		fields = append(fields, task.FieldArgs)
	}
	if m.FieldCleared(task.FieldData) {
		fields = append(fields, task.FieldData)
	}
	if m.FieldCleared(task.FieldResult) {
		fields = append(fields, task.FieldResult)
	}
	if m.FieldCleared(task.FieldCompletedat) {
		fields = append(fields, task.FieldCompletedat)
	}
	if m.FieldCleared(task.FieldTTPs) {
		fields = append(fields, task.FieldTTPs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldArgs:
		m.ClearArgs()
		return nil
	case task.FieldData:
		m.ClearData()
		return nil
	case task.FieldResult:
		m.ClearResult()
		return nil
	case task.FieldCompletedat:
		m.ClearCompletedat()
		return nil
	case task.FieldTTPs:
		m.ClearTTPs()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldXid:
		m.ResetXid()
		return nil
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldArgs:
		m.ResetArgs()
		return nil
	case task.FieldData:
		m.ResetData()
		return nil
	case task.FieldResult:
		m.ResetResult()
		return nil
	case task.FieldExecuted:
		m.ResetExecuted()
		return nil
	case task.FieldLooted:
		m.ResetLooted()
		return nil
	case task.FieldRequestedat:
		m.ResetRequestedat()
		return nil
	case task.FieldCompletedat:
		m.ResetCompletedat()
		return nil
	case task.FieldTTPs:
		m.ResetTTPs()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.rodent != nil {
		edges = append(edges, task.EdgeRodent)
	}
	if m.loot != nil {
		edges = append(edges, task.EdgeLoot)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeRodent:
		if id := m.rodent; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeLoot:
		ids := make([]ent.Value, 0, len(m.loot))
		for id := range m.loot {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedloot != nil {
		edges = append(edges, task.EdgeLoot)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeLoot:
		ids := make([]ent.Value, 0, len(m.removedloot))
		for id := range m.removedloot {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrodent {
		edges = append(edges, task.EdgeRodent)
	}
	if m.clearedloot {
		edges = append(edges, task.EdgeLoot)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeRodent:
		return m.clearedrodent
	case task.EdgeLoot:
		return m.clearedloot
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeRodent:
		m.ClearRodent()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeRodent:
		m.ResetRodent()
		return nil
	case task.EdgeLoot:
		m.ResetLoot()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *int
	username       *string
	givenname      *string
	email          *string
	owned          *bool
	age            *string
	homedir        *string
	enabled        *bool
	clearedFields  map[string]struct{}
	devices        map[int]struct{}
	removeddevices map[int]struct{}
	cleareddevices bool
	rodents        map[int]struct{}
	removedrodents map[int]struct{}
	clearedrodents bool
	groups         map[int]struct{}
	removedgroups  map[int]struct{}
	clearedgroups  bool
	domain         *int
	cleareddomain  bool
	done           bool
	oldValue       func(context.Context) (*User, error)
	predicates     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetGivenname sets the "givenname" field.
func (m *UserMutation) SetGivenname(s string) {
	m.givenname = &s
}

// Givenname returns the value of the "givenname" field in the mutation.
func (m *UserMutation) Givenname() (r string, exists bool) {
	v := m.givenname
	if v == nil {
		return
	}
	return *v, true
}

// OldGivenname returns the old "givenname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGivenname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGivenname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGivenname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGivenname: %w", err)
	}
	return oldValue.Givenname, nil
}

// ResetGivenname resets all changes to the "givenname" field.
func (m *UserMutation) ResetGivenname() {
	m.givenname = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetOwned sets the "owned" field.
func (m *UserMutation) SetOwned(b bool) {
	m.owned = &b
}

// Owned returns the value of the "owned" field in the mutation.
func (m *UserMutation) Owned() (r bool, exists bool) {
	v := m.owned
	if v == nil {
		return
	}
	return *v, true
}

// OldOwned returns the old "owned" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOwned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwned: %w", err)
	}
	return oldValue.Owned, nil
}

// ResetOwned resets all changes to the "owned" field.
func (m *UserMutation) ResetOwned() {
	m.owned = nil
}

// SetAge sets the "age" field.
func (m *UserMutation) SetAge(s string) {
	m.age = &s
}

// Age returns the value of the "age" field in the mutation.
func (m *UserMutation) Age() (r string, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// ClearAge clears the value of the "age" field.
func (m *UserMutation) ClearAge() {
	m.age = nil
	m.clearedFields[user.FieldAge] = struct{}{}
}

// AgeCleared returns if the "age" field was cleared in this mutation.
func (m *UserMutation) AgeCleared() bool {
	_, ok := m.clearedFields[user.FieldAge]
	return ok
}

// ResetAge resets all changes to the "age" field.
func (m *UserMutation) ResetAge() {
	m.age = nil
	delete(m.clearedFields, user.FieldAge)
}

// SetHomedir sets the "homedir" field.
func (m *UserMutation) SetHomedir(s string) {
	m.homedir = &s
}

// Homedir returns the value of the "homedir" field in the mutation.
func (m *UserMutation) Homedir() (r string, exists bool) {
	v := m.homedir
	if v == nil {
		return
	}
	return *v, true
}

// OldHomedir returns the old "homedir" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHomedir(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomedir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomedir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomedir: %w", err)
	}
	return oldValue.Homedir, nil
}

// ResetHomedir resets all changes to the "homedir" field.
func (m *UserMutation) ResetHomedir() {
	m.homedir = nil
}

// SetEnabled sets the "enabled" field.
func (m *UserMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *UserMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *UserMutation) ResetEnabled() {
	m.enabled = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *UserMutation) AddDeviceIDs(ids ...int) {
	if m.devices == nil {
		m.devices = make(map[int]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *UserMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *UserMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *UserMutation) RemoveDeviceIDs(ids ...int) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *UserMutation) RemovedDevicesIDs() (ids []int) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *UserMutation) DevicesIDs() (ids []int) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *UserMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddRodentIDs adds the "rodents" edge to the Rodent entity by ids.
func (m *UserMutation) AddRodentIDs(ids ...int) {
	if m.rodents == nil {
		m.rodents = make(map[int]struct{})
	}
	for i := range ids {
		m.rodents[ids[i]] = struct{}{}
	}
}

// ClearRodents clears the "rodents" edge to the Rodent entity.
func (m *UserMutation) ClearRodents() {
	m.clearedrodents = true
}

// RodentsCleared reports if the "rodents" edge to the Rodent entity was cleared.
func (m *UserMutation) RodentsCleared() bool {
	return m.clearedrodents
}

// RemoveRodentIDs removes the "rodents" edge to the Rodent entity by IDs.
func (m *UserMutation) RemoveRodentIDs(ids ...int) {
	if m.removedrodents == nil {
		m.removedrodents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rodents, ids[i])
		m.removedrodents[ids[i]] = struct{}{}
	}
}

// RemovedRodents returns the removed IDs of the "rodents" edge to the Rodent entity.
func (m *UserMutation) RemovedRodentsIDs() (ids []int) {
	for id := range m.removedrodents {
		ids = append(ids, id)
	}
	return
}

// RodentsIDs returns the "rodents" edge IDs in the mutation.
func (m *UserMutation) RodentsIDs() (ids []int) {
	for id := range m.rodents {
		ids = append(ids, id)
	}
	return
}

// ResetRodents resets all changes to the "rodents" edge.
func (m *UserMutation) ResetRodents() {
	m.rodents = nil
	m.clearedrodents = false
	m.removedrodents = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *UserMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *UserMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *UserMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *UserMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *UserMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *UserMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *UserMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// SetDomainID sets the "domain" edge to the Domain entity by id.
func (m *UserMutation) SetDomainID(id int) {
	m.domain = &id
}

// ClearDomain clears the "domain" edge to the Domain entity.
func (m *UserMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the Domain entity was cleared.
func (m *UserMutation) DomainCleared() bool {
	return m.cleareddomain
}

// DomainID returns the "domain" edge ID in the mutation.
func (m *UserMutation) DomainID() (id int, exists bool) {
	if m.domain != nil {
		return *m.domain, true
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DomainID instead. It exists only for internal usage by the builders.
func (m *UserMutation) DomainIDs() (ids []int) {
	if id := m.domain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *UserMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.givenname != nil {
		fields = append(fields, user.FieldGivenname)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.owned != nil {
		fields = append(fields, user.FieldOwned)
	}
	if m.age != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.homedir != nil {
		fields = append(fields, user.FieldHomedir)
	}
	if m.enabled != nil {
		fields = append(fields, user.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldGivenname:
		return m.Givenname()
	case user.FieldEmail:
		return m.Email()
	case user.FieldOwned:
		return m.Owned()
	case user.FieldAge:
		return m.Age()
	case user.FieldHomedir:
		return m.Homedir()
	case user.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldGivenname:
		return m.OldGivenname(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldOwned:
		return m.OldOwned(ctx)
	case user.FieldAge:
		return m.OldAge(ctx)
	case user.FieldHomedir:
		return m.OldHomedir(ctx)
	case user.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldGivenname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGivenname(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldOwned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwned(v)
		return nil
	case user.FieldAge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case user.FieldHomedir:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomedir(v)
		return nil
	case user.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAge) {
		fields = append(fields, user.FieldAge)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAge:
		m.ClearAge()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldGivenname:
		m.ResetGivenname()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldOwned:
		m.ResetOwned()
		return nil
	case user.FieldAge:
		m.ResetAge()
		return nil
	case user.FieldHomedir:
		m.ResetHomedir()
		return nil
	case user.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.devices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.rodents != nil {
		edges = append(edges, user.EdgeRodents)
	}
	if m.groups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m.domain != nil {
		edges = append(edges, user.EdgeDomain)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRodents:
		ids := make([]ent.Value, 0, len(m.rodents))
		for id := range m.rodents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDomain:
		if id := m.domain; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddevices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.removedrodents != nil {
		edges = append(edges, user.EdgeRodents)
	}
	if m.removedgroups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRodents:
		ids := make([]ent.Value, 0, len(m.removedrodents))
		for id := range m.removedrodents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddevices {
		edges = append(edges, user.EdgeDevices)
	}
	if m.clearedrodents {
		edges = append(edges, user.EdgeRodents)
	}
	if m.clearedgroups {
		edges = append(edges, user.EdgeGroups)
	}
	if m.cleareddomain {
		edges = append(edges, user.EdgeDomain)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDevices:
		return m.cleareddevices
	case user.EdgeRodents:
		return m.clearedrodents
	case user.EdgeGroups:
		return m.clearedgroups
	case user.EdgeDomain:
		return m.cleareddomain
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeDomain:
		m.ClearDomain()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDevices:
		m.ResetDevices()
		return nil
	case user.EdgeRodents:
		m.ResetRodents()
		return nil
	case user.EdgeGroups:
		m.ResetGroups()
		return nil
	case user.EdgeDomain:
		m.ResetDomain()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
